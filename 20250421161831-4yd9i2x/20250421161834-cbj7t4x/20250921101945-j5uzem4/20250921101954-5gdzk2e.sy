{"ID":"20250921101954-5gdzk2e","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250921101954-5gdzk2e","title":"vector","type":"doc","updated":"20250921192157"},"Children":[{"ID":"20250921102007-mooy355","Type":"NodeParagraph","Properties":{"id":"20250921102007-mooy355","updated":"20250921102007"},"Children":[{"Type":"NodeText","Data":"vector"}]},{"ID":"20250921102007-gxb7hou","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250921102007-gxb7hou","updated":"20250921192157"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"方法：\nassign   清空元素并插入，\n\tvector\u003cint\u003e temp;\n\tassign(temp.begin(),temp.end());\n\tchar array[33];\n\tassign(array,array+sizeof(array));\n\tassign(8,6);  eight sixes\n\tassign({3,2,5,6})\npop_back push_back push_front\ninsert(3,11)  3前面插入11\nerase(temp.begin())  erase(temp.end())\n扩容:resie(30)   如果resize小的话清空多余的，但是capacity还是原来的\n\tresize(30,5) //当前大小扩容到30，新内容全是5\n\tresize(4,5)  //二维的话，二维扩充到4，一维size是5\n随机访问：\n\ttemp【2】  效率高\n\ttemp.at(2)  会内存检查\n\ttemp.front()\n\ttemp.back()\n内存交换\n\ttemp1 temp2\n\ttemp1.swap(temp2)  //vector 会发生交换   实际是交换指针\n\tvector\u003c\u003e(temp1).swap(temp1) //交换后不会缩容，大小还是那么大,匿名构造交换进行缩容  因为交换了指针\n清理：\n\tclear（） 不会缩容，只会清size\t \n空间预留：\n\ttemp.reserve（100） 扩容，但无size\n高效删除：\n\t swap(temp[index],temp.back() ； temp.pop_back() //精辟, 前提是不关心顺序\n排序：\n\tbool cmp(int a,int b){\n\t\treturn a\u003eb;\n\t}\n\tsort（temp.begin(),temp.end(),cmp);\n空间清理：\n\tshrink_to_fit() //清理大于size的capacity\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}