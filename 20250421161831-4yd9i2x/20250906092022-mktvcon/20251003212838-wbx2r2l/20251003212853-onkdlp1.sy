{"ID":"20251003212853-onkdlp1","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251003212853-onkdlp1","title":"泛型Generics","type":"doc","updated":"20251010154452"},"Children":[{"ID":"20251010154429-d2d4uyh","Type":"NodeParagraph","Properties":{"id":"20251010154429-d2d4uyh","updated":"20251010154452"},"Children":[{"Type":"NodeText","Data":"Rust 通过在编译时进行泛型代码的 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"单态化"},{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"monomorphization"},{"Type":"NodeText","Data":")来保证效率，我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码"}]},{"ID":"20251003212853-emwubar","Type":"NodeParagraph","Properties":{"id":"20251003212853-emwubar","updated":"20251003213002"},"Children":[{"Type":"NodeText","Data":"好像C++中的模版"}]},{"ID":"20251003213004-99lfwsu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003213004-99lfwsu","updated":"20251003223946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn add\u003cT\u003e(a:T, b:T) -\u003e T {  //不行，要告诉add哪些类型可以加\nfn add\u003cT: std::ops::Add\u003cOutput = T\u003e\u003e(a:T, b:T) -\u003e T { //行，std::ops::Add\u003cOutput = T\u003e是特征约束\n    a + b\n}\nfn add\u003cT\u003e(a: T, b: T) -\u003e T where T:std::ops::Add\u003cOutput = T\u003e + Copy + From\u003ci32\u003e{\n\tlet a: T = 100.into();//From的含义是T是i32转换过来的\n    a + b \n}   //这里optput约束的是特征ADD或者SUB返回的数值是什么， 这里是显示指定\nfn main() {\n    println!(\"add i8: {}\", add(2i8, 3i8));\n    println!(\"add i32: {}\", add(20, 30));\n    println!(\"add f64: {}\", add(1.23, 1.23));\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251003215049-rkevoyl","Type":"NodeParagraph","Properties":{"id":"20251003215049-rkevoyl","updated":"20251003215055"},"Children":[{"Type":"NodeText","Data":"特征约束："}]},{"ID":"20251003215055-woe7bas","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003215055-woe7bas","updated":"20251003221005"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"std::ops::Add\u003cOutput = T\u003e\n其中类型有：\nstd::ops::Add       // + 加法\nstd::ops::Sub       // - 减法  \nstd::ops::Mul       // * 乘法\nstd::ops::Div       // / 除法\nstd::ops::Rem       // % 取余\nstd::ops::Index     // [] 索引\nstd::ops::Deref     // * 解引用\nstd::ops::Drop      // 析构\nstd::ops::Range     // .. 范围\nstd::ops::Fn        // 函数调用\nstd::ops::Copy      // copy      //Copy特征\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251003224218-ql6hlff","Type":"NodeParagraph","Properties":{"id":"20251003224218-ql6hlff","updated":"20251003224707"},"Children":[{"Type":"NodeText","Data":"结构体使用泛型："}]},{"ID":"20251003224232-tsyvsw8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003224232-tsyvsw8","updated":"20251003224409"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Point\u003cT\u003e {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 2 }; //报错，x ,y类型不同了\n}\n//多类型赋值\nstruct Point\u003cT,U\u003e {\n    x: T,\n    y: U,\n}\nfn main() {\n    let p = Point{x: 1, y :1.1};\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251003224656-kiq6ybm","Type":"NodeParagraph","Properties":{"id":"20251003224656-kiq6ybm","updated":"20251003224712"},"Children":[{"Type":"NodeText","Data":"枚举使用泛型："}]},{"ID":"20251003224713-orvwo05","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003224713-orvwo05","updated":"20251003232647"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"enum Option\u003cT\u003e {  //很经典，标准库里面本来就有\n    Some(T),\n    None,\n}\nenum Result\u003cT, E\u003e {\n    Ok(T),   // 成功，包含值 T\n    Err(E),  // 失败，包含错误 E\n}\n\nfn divide(a: f64, b: f64) -\u003e Result\u003cf64, String\u003e {\n    if b == 0.0 {\n        Err(\"Cannot divide by zero\".to_string())  // 错误情况\n    } else {\n        Ok(a / b)  // 成功情况\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251003224700-1ekcvy9","Type":"NodeParagraph","Properties":{"id":"20251003224700-1ekcvy9","updated":"20251003232656"},"Children":[{"Type":"NodeText","Data":"方法使用泛型："}]},{"ID":"20251003232656-bm7jgko","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003232656-bm7jgko","updated":"20251003233830"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Point\u003cT, U\u003e {\n    x: T,\n    y: U,\n}\n\nimpl\u003cT, U\u003e Point\u003cT, U\u003e {   \n    fn mixup\u003cV, W\u003e(self, other: Point\u003cV, W\u003e) -\u003e Point\u003cT, W\u003e {  //这里返回了T，W类型，编译会检查\n        Point {   //基于TU新增的VW\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c'};\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n\nimpl Point\u003cf32\u003e {   //针对泛型实现具体方法\n    fn distance_from_origin(\u0026self) -\u003e f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251003234452-hxl2ifd","Type":"NodeParagraph","Properties":{"id":"20251003234452-hxl2ifd","updated":"20251003234913"},"Children":[{"Type":"NodeText","Data":"const泛型：以前 Rust 的一些数组库使用的时候都限定长度不超过 32，因为它们会为每个长度都单独实现一个函数"}]},{"ID":"20251003234456-uprshbz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251003234456-uprshbz","updated":"20251003235504"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn display_array\u003cT: std::fmt::Debug\u003e(arr: \u0026[T]) {   因为输入的是数组，所以引用，然后规定有Debug特征，T类型\nfn display_array\u003cT: std::fmt::Debug, const N: usize\u003e(arr: [T; N]) {//改进，const泛型，可以定义大小\n    println!(\"{:?}\", arr);\n}\nfn main() {\n    let arr: [i32; 3] = [1, 2, 3];\n    display_array(\u0026arr);\n\n    let arr: [i32; 2] = [1, 2];\n    display_array(\u0026arr);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010154054-maegm65","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20251010154054-maegm65","updated":"20251010154426"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/basic/trait/generic.html#const-fn-%E7%9A%84%E9%99%90%E5%88%B6","TextMarkTextContent":"const fn "},{"Type":"NodeText","Data":"：在编译期执行，传参是常量"}]},{"ID":"20251010154056-b5quc7l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010154056-b5quc7l","updated":"20251010154141"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Buffer\u003cconst N: usize\u003e {\n    data: [u8; N],\n}\n\nconst fn compute_buffer_size(factor: usize) -\u003e usize {\n    factor * 1024\n}\n\nfn main() {\n    const SIZE: usize = compute_buffer_size(4);\n    let buffer = Buffer::\u003cSIZE\u003e {\n        data: [0; SIZE],\n    };\n    println!(\"Buffer size: {} bytes\", buffer.data.len());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010154426-wqf1koy","Type":"NodeParagraph","Properties":{"id":"20251010154426-wqf1koy","updated":"20251010154426"}}]}