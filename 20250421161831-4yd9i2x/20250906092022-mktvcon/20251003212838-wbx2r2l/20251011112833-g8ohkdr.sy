{"ID":"20251011112833-g8ohkdr","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251011112833-g8ohkdr","title":"特征对象","type":"doc","updated":"20251012014156"},"Children":[{"ID":"20251011112833-yprxzvz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251011112833-yprxzvz","updated":"20251011231511"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"trait Draw {\n    fn draw(\u0026self);\n}\n// 特征对象的两种常见形式：\nlet obj1: \u0026dyn Draw = \u0026some_value;      // 引用形式\nlet obj2: Box\u003cdyn Draw\u003e = Box::new(value); // Box 形式\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251011231852-0apew63","Type":"NodeParagraph","Properties":{"id":"20251011231852-0apew63","updated":"20251011234454"},"Children":[{"Type":"NodeText","Data":"多种实例："}]},{"ID":"20251011234454-b6jlflt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251011234454-b6jlflt","updated":"20251011234545"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub struct Screen\u003cT: Draw\u003e {   //通过泛型，Vec被固定住一个T类型了，也就是类型单一了\n    pub components: Vec\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Screen\u003cT\u003e\n    where T: Draw {\n    pub fn run(\u0026self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\npub struct Screen {  //多类型，只要实现了Draw都可以放进去，多类型数组\n    pub components: Vec\u003cBox\u003cdyn Draw\u003e\u003e,\n}\nimpl Screen {\n    pub fn run(\u0026self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012003622-iwh8nqm","Type":"NodeParagraph","Properties":{"id":"20251012003622-iwh8nqm","updated":"20251012003828"},"Children":[{"Type":"NodeText","Data":"Self和self：Self是自身实例的类型，self是指向自身实例，好像C++里的this，Self self都是关键字"}]},{"ID":"20251012003626-kau14pq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012003626-kau14pq","updated":"20251012004030"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"trait Draw {\n    fn draw(\u0026self) -\u003e Self;\n}\n\n#[derive(Clone)]\nstruct Button;\nimpl Draw for Button {\n    fn draw(\u0026self) -\u003e Self {\n        return self.clone()\n    }\n}\n这里\u0026self有一个语法糖：\nfn draw(\u0026self) == fn draw(self:\u0026Self)（一样） == fn draw(self:\u0026Button)（不建议，类型被定死了）\nfn main() {\n    let button = Button;\n    let newb = button.draw();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012012427-a78z41g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251012012427-a78z41g","updated":"20251012014156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/basic/trait/trait-object.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%90%E5%88%B6","TextMarkTextContent":"特征对象的限制"},{"Type":"NodeText","Data":"："}]},{"ID":"20251012012447-4btl2zg","Type":"NodeParagraph","Properties":{"id":"20251012012447-4btl2zg","updated":"20251012012447"},"Children":[{"Type":"NodeText","Data":"只有对象安全的特征才行"}]},{"ID":"20251012012440-78dbdug","Type":"NodeList","ListData":{},"Properties":{"id":"20251012012440-78dbdug","updated":"20251012012849"},"Children":[{"ID":"20251012012440-uat1xp4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251012012440-uat1xp4","updated":"20251012012440"},"Children":[{"ID":"20251012012440-8vit08a","Type":"NodeParagraph","Properties":{"id":"20251012012440-8vit08a","updated":"20251012012440"},"Children":[{"Type":"NodeText","Data":"方法的返回类型不能是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Self"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251012012440-8ocl0nm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251012012440-8ocl0nm","updated":"20251012012849"},"Children":[{"ID":"20251012012440-r5isrx5","Type":"NodeParagraph","Properties":{"id":"20251012012440-r5isrx5","updated":"20251012012849"},"Children":[{"Type":"NodeText","Data":"方法没有任何泛型参数"}]}]}]},{"ID":"20251012012449-u9tcigr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012012449-u9tcigr","updated":"20251012014156"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"1.方法的返回类型不能是 Self\n// 定义时：vtable 订好了\nimpl Clone for Button {\n    fn clone(\u0026self) -\u003e Self { Button }\n    //                 ^^^^ Self = Button（1字节）\n}\nimpl Clone for TextField {\n    fn clone(\u0026self) -\u003e Self { TextField { ... } }\n    //                 ^^^^ Self = TextField（24字节）\n}\n// 使用时：不知道返回什么\nfn use_clone(obj: \u0026dyn Clone) {   //***这里返回Clone，但是传入的是上级，无法分配空间***//\n    let result = obj.clone();\n    //   ^^^^^^ result 应该分配多大空间？\n    //   编译器不知道！\n}\n2.方法没有任何泛型参数\n两个原因：\n\t1.虚表需要再编译时确定，特征对象定义时，要知道具体类型，如果是泛型则会发生非常多的情况，全部穷举不现实\n\t2.如果调用，则参数是未知的，传入的是特征对象，但是调用的是泛型，1中不会实现当前调用泛型的虚表方法。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012012833-jphugs3","Type":"NodeParagraph","Properties":{"id":"20251012012833-jphugs3","updated":"20251012012833"}}]}