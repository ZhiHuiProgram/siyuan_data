{"ID":"20251012183713-w6di192","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251012183713-w6di192","title":"动态数组Vector","type":"doc","updated":"20251013112119"},"Children":[{"ID":"20251012183713-iaj1yxz","Type":"NodeParagraph","Properties":{"id":"20251012183713-iaj1yxz","updated":"20251012183956"},"Children":[{"Type":"NodeText","Data":"定义："}]},{"ID":"20251012183957-zuaw18j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012183957-zuaw18j","linewrap":"false","updated":"20251013110159"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"Vec\u003cT\u003e\n\nlet v: Vec\u003ci32\u003e = Vec::new(); //new一个空的\n\nlet mut s = Vec::with_capacity(capacity); //new一个可变vec容量为capacity， 后面有push的话会自动推导类型\nv.extend([1, 2, 3]);  //开辟容量后快速填充数据\nv.reserve(100);  //修改容量，至少100，不能小于当前\nv.shrink_to_fit();  //释放多余的容量\n\nlet mut v = Vec::new();  //new一个可变vec， 后面有push的话会自动推导类型\nv.push(1);\n\nlet v = vec![1, 2, 3];  直接初始化\nlet v = vec![0; 3];   初始化3个0\nlet v_from = Vec::from([0, 0, 0]);  //和String有点像\n\n作用域限制：\n{\n    let v = vec![1, 2, 3];\n\n    // ...\n}\n常用例子：\n\tassert!(!v.is_empty()); \n\tv.insert(2, 3);  //位置2插入3\n\tassert_eq!(v.remove(1), 2); //移除后会返回移除的数据\n\tassert_eq!(v.pop(), Some(3)); //pop尾部数据，返回的是枚举值\n\tv.clear();  //清空\n\n\tlet mut v1 = [11, 22].to_vec();\n\tv.append(\u0026mut v1); //特性，append会清空输入的数据\n\tv.extend(v1.iter());  //追加尾部，不会清空\n\tv.truncate(1);    //截断到长度1，只剩下第一个元素了\n\tv.retain(|x| *x \u003e 10);隐式 //保留满足条件的元素，删除不满足条件的元素  //|\u0026x| x \u003e3  |x:\u0026i32| *x \u003e3显示\n\tlet mut m: Vec\u003c_\u003e = v.drain(1..=3).collect(); //删除指定范围元素，返回移除的元素Vec\n\tlet v2 = m.split_off(1);  //指定索引处切分为两个， m 和 v2\n\t\n\tlet slice = \u0026v[1..=3];数组切片，之前就讲过\n访问元素：\n\tlet v = vec![1, 2, 3, 4, 5];\n\tlet third: \u0026i32 = \u0026v[2];  \n\tprintln!(\"第三个元素是 {}\", third);  //这里会自动解引用\n\n\n\tmatch v.get(2) { //这里get因为不确定返回有没有东西，所以返回的是一个Option枚举\n\t    Some(third) =\u003e println!(\"第三个元素是 {third}\"),\n\t    None =\u003e println!(\"去你的第三个元素，根本没有！\"),\n\t}\n\n排序：\n\t有很多排序方法，常用两个\n\tvec.sort()\t\t\t//稳定排序，相等时保持原顺序\n\tvec.sort_by(|a, b| ...); \n\tvec.sort_unstable();  //不稳定排序，相等时可能会打乱顺序\n\tvec.sort_unstable_by(|a, b| ...);\n\t//整数\n\tlet mut vec = vec![1, 5, 10, 2, 15];     \n    vec.sort_unstable();  \n\tassert_eq!(vec, vec![1, 2, 5, 10, 15]);\n\t//浮点数，不能直接比较，因为存在NAN值，浮点数类型并没有实现全数值可比较 Ord 的特性，而是实现了部分可比较的特性 PartialOrd\n\tlet mut vec = vec![1.0, 5.6, 10.3, 2.0, 15f32];    \n    vec.sort_unstable_by(|a, b| a.total_cmp(b));     \t \t//直接返回Option\u003cOrdering\u003e里面的Ordering\n    vec.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap()); //partial_cmp返回的是Option\u003cOrdering\u003e类型，使用unwrap会提取里面的值，返回Ordering\n    assert_eq!(vec, vec![1.0, 2.0, 5.6, 10.3, 15f32]);\n\t//结构体排序\n\tstruct Person {\n  \t  name: String,\n      age: u32,\n\t}\n\timpl Person {\n \t   fn new(name: String, age: u32) -\u003e Person {\n\t        Person { name, age }\n\t    }\n\t}\n\tfn main() {\n\t    let mut people = vec![\n \t       Person::new(\"Zoe\".to_string(), 25),\n  \t       Person::new(\"Al\".to_string(), 60),\n \t       Person::new(\"John\".to_string(), 1),\n\t    ];\n\t    // 定义一个按照年龄倒序排序的对比函数\n\t    people.sort_unstable_by(|a, b| b.age.cmp(\u0026a.age)); //a.age与b.age比较\n\t\n\t    println!(\"{:?}\", people);\n\t}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251013110650-pwh8h9o","Type":"NodeParagraph","Properties":{"id":"20251013110650-pwh8h9o","updated":"20251013110842"},"Children":[{"Type":"NodeText","Data":"排序扩展："}]},{"ID":"20251013110654-mdpnd5k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251013110654-mdpnd5k","updated":"20251013112119"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nimpl Person {\n    fn new(name: String, age: u32) -\u003e Person {\n        Person { name, age }\n    }\n}\n\nfn main() {\n    let mut people = vec![\n        Person::new(\"Zoe\".to_string(), 25),\n        Person::new(\"Al\".to_string(), 60),\n        Person::new(\"Al\".to_string(), 30),\n        Person::new(\"John\".to_string(), 1),\n        Person::new(\"John\".to_string(), 25),\n    ];\n\n    people.sort_unstable();   //这时，按照Person的第一个字段开始排序，如果相等，则排序下一个字段\n\n    println!(\"{:?}\", people);\n}\n扩展：\n// ✅ 优点：简洁，但是升序简单，且必须实现Ord，降序有些麻烦。\npeople.sort_unstable_by_key(|p| (\u0026p.name, p.age));\n\n// ✅ 优点：灵活，可以写复杂逻辑\npeople.sort_unstable_by(|a, b| {\n    a.name.cmp(\u0026b.name)\n        .then(a.age.cmp(\u0026b.age))\n});\n\n// ✅ 优点：可以处理 PartialOrd（浮点数）\npeople.sort_unstable_by(|a, b| {\n    a.score.total_cmp(\u0026b.score)\n        .then(a.name.cmp(\u0026b.name))\n});\n\n// ✅ 优点：可以降序\npeople.sort_unstable_by(|a, b| {\n    b.age.cmp(\u0026a.age)  // 注意是 b.cmp(\u0026a)，降序\n});\n1.\n\t#[derive(Debug, PartialEq, Eq)]  // 只 derive 必要的\n\tstruct Person {\n\t    name: String,\n\t    age: u32,\n\t}\n\t\n\tfn main() {\n\t    people.sort_unstable_by_key(|p| (\u0026p.name, p.age));  \n\t    // 或多条件\n\t    people.sort_unstable_by(|a, b| {\n\t        a.name.cmp(\u0026b.name)\n\t            .then(a.age.cmp(\u0026b.age))\n\t    });\n\t}\n2.\n\timpl Ord for Person {\n\t    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n\t        // 明确的排序逻辑\n\t        self.name.cmp(\u0026other.name)\n\t            .then(self.age.cmp(\u0026other.age))\n\t    }\n\t}\n\n\timpl PartialOrd for Person {\n\t    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n\t        Some(self.cmp(other))\n\t    }\n\t}\n3.\n\t// 如果字段顺序就是你想要的排序顺序，可以用\n\t// 但最好加注释说明\n\t#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]\n\tstruct Person {\n\t    name: String,  // 主排序键\n\t    age: u32,      // 次排序键\n\t}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012222231-9ms757t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251012222231-9ms757t","updated":"20251013110648"},"Children":[{"Type":"NodeText","Data":"迭代遍历 Vector 中的元素"}]},{"ID":"20251012222232-2498zwy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012222232-2498zwy","updated":"20251012222316"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let v = vec![1, 2, 3];\nfor i in \u0026v {\n    println!(\"{i}\");\n}\n\nlet mut v = vec![1, 2, 3];\nfor i in \u0026mut v {\n    *i += 10\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012222307-o2wijz5","Type":"NodeParagraph","Properties":{"id":"20251012222307-o2wijz5","updated":"20251012222412"},"Children":[{"Type":"NodeText","Data":"存储不同类型的元素：枚举法"}]},{"ID":"20251012222402-854oyqc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012222402-854oyqc","updated":"20251012222407"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"#[derive(Debug)]\nenum IpAddr {\n    V4(String),\n    V6(String)\n}\nfn main() {\n    let v = vec![\n        IpAddr::V4(\"127.0.0.1\".to_string()),\n        IpAddr::V6(\"::1\".to_string())\n    ];\n\n    for ip in v {\n        show_addr(ip)\n    }\n}\n\nfn show_addr(ip: IpAddr) {\n    println!(\"{:?}\",ip);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012222415-guu5bbj","Type":"NodeParagraph","Properties":{"id":"20251012222415-guu5bbj","updated":"20251012222429"},"Children":[{"Type":"NodeText","Data":"存储不同类型的元素：特征对象"}]},{"ID":"20251012222429-rikx0vt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012222429-rikx0vt","updated":"20251012222458"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"trait IpAddr {\n    fn display(\u0026self);\n}\n\nstruct V4(String);\nimpl IpAddr for V4 {\n    fn display(\u0026self) {\n        println!(\"ipv4: {:?}\",self.0)\n    }\n}\nstruct V6(String);\nimpl IpAddr for V6 {\n    fn display(\u0026self) {\n        println!(\"ipv6: {:?}\",self.0)\n    }\n}\n\nfn main() {\n    let v: Vec\u003cBox\u003cdyn IpAddr\u003e\u003e = vec![\n        Box::new(V4(\"127.0.0.1\".to_string())),\n        Box::new(V6(\"::1\".to_string())),\n    ];\n\n    for ip in v {\n        ip.display();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012223548-0xz25a8","Type":"NodeParagraph","Properties":{"id":"20251012223548-0xz25a8","updated":"20251012223548"}}]}