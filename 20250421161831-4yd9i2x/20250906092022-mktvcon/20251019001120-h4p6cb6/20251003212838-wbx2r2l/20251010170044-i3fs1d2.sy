{"ID":"20251010170044-i3fs1d2","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251010170044-i3fs1d2","title":"特征Trait","type":"doc","updated":"20251010223715"},"Children":[{"ID":"20251010170044-rsd1y15","Type":"NodeParagraph","Properties":{"id":"20251010170044-rsd1y15","updated":"20251010170112"},"Children":[{"Type":"NodeText","Data":"抽象一个接口"}]},{"ID":"20251010170403-z72q4lf","Type":"NodeParagraph","Properties":{"id":"20251010170403-z72q4lf","updated":"20251010170403"},"Children":[{"Type":"NodeText","Data":"特征定义了"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一组可以被共享的行为，只要实现了特征，你就能使用这组行为"},{"Type":"NodeText","Data":"。"}]},{"ID":"20251010170404-ugfluqc","Type":"NodeParagraph","Properties":{"id":"20251010170404-ugfluqc","updated":"20251010170414"},"Children":[{"Type":"NodeText","Data":"定义"}]},{"ID":"20251010170415-lp55jgi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010170415-lp55jgi","updated":"20251010170420"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub trait Summary {\n    fn summarize(\u0026self) -\u003e String;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010170421-hap2xez","Type":"NodeParagraph","Properties":{"id":"20251010170421-hap2xez","updated":"20251010175614"},"Children":[{"Type":"NodeText","Data":"孤儿规则：非常重要的原则："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果你想要为类型"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实现特征"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，那么"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"或者"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"至少有一个是在当前作用域中定义的"}]},{"ID":"20251010175743-5uwtk2b","Type":"NodeParagraph","Properties":{"id":"20251010175743-5uwtk2b","updated":"20251010175822"},"Children":[{"Type":"NodeText","Data":"方法接口：特征实现了功能，另一个接口实现输入"}]},{"ID":"20251010175747-xli0e9f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010175747-xli0e9f","updated":"20251010180027"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub trait Summary {\n    fn summarize_author(\u0026self) -\u003e String;\n\n    fn summarize(\u0026self) -\u003e String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\nimpl Summary for Weibo {\n    fn summarize_author(\u0026self) -\u003e String {\n        format!(\"@{}\", self.username)\n    }\n}\nprintln!(\"1 new weibo: {}\", weibo.summarize());\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010180025-avo1ssw","Type":"NodeParagraph","Properties":{"id":"20251010180025-avo1ssw","updated":"20251010180048"},"Children":[{"Type":"NodeText","Data":"作为参数传递：任何实现了该特征方法的类型都可以传进来"}]},{"ID":"20251010180032-2yrwray","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010180032-2yrwray","updated":"20251010215826"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub fn notify(item: \u0026impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n甚至多特征\nfn notify(item: \u0026(impl Summary + Display))\n\n语法糖：\npub fn notify\u003cT: Summary\u003e(item: \u0026T)；用了泛型加特征约束，但是直接传用有特征的类型也一样\n\n用where实现：\nfn some_function\u003cT, U\u003e(t: \u0026T, u: \u0026U) -\u003e i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n\nimpl\u003cT: Display\u003e ToString for T {\n    // --snip--\n}标准库为每个有Display特征的东西实现了tostring方法\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010180049-bclx93p","Type":"NodeParagraph","Properties":{"id":"20251010180049-bclx93p","updated":"20251010215903"},"Children":[{"Type":"NodeText","Data":"函数返回种的impl trait特征"}]},{"ID":"20251010215909-4hytcuo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010215909-4hytcuo","updated":"20251010220052"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn returns_summarizable() -\u003e impl Summary {\n    Weibo {   //实现了Summary特征 的类型都可以作返回值返回类型难以判断时这样用\n        username: String::from(\"sunface\"),\n        content: String::from(\n            \"m1 max太厉害了，电脑再也不会卡\",\n        )\n    }\n}有限制//只能返回weibo了，不能返回其他的类型\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010220053-3si0r1i","Type":"NodeParagraph","Properties":{"id":"20251010220053-3si0r1i","updated":"20251010221209"},"Children":[{"Type":"NodeText","Data":"通过derive派生特征：derive 派生宏，属性宏"}]},{"ID":"20251010220927-gxvu6e6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010220927-gxvu6e6","updated":"20251010223025"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当声明了派生宏后，\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n\nTrait\t\t作用\t\t\t示例\nDebug\t\t调试打印\t\tprintln!(\"{:?}\", obj)\nClone\t\t克隆对象\t\tobj.clone()\nCopy\t\t按位复制\t\tlet b = a; (a 仍可用)\nPartialEq\t相等比较\t\ta == b\nEq\t\t\t完全相等\t\t标记类型满足相等性\nPartialOrd\t部分排序\t\ta \u003c b, a.partial_cmp(\u0026b)\nOrd\t\t\t全排序\t\ta.cmp(\u0026b), 可用于 sort()\nHash\t\t哈希计算\t\t可用作 HashMap 的 key\n\n使用方法：\n在类型上面声明：\n#[derive(Debug)]\nstruct test{\n    x: i32,\n    y: i32,\n}\nstruct test1{ 这里test1没有Debug特征，因为derive只在一个类型上面有效\n    x:i32,\n    y:String,\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010221242-i3sf2sf","Type":"NodeParagraph","Properties":{"id":"20251010221242-i3sf2sf","updated":"20251010223619"},"Children":[{"Type":"NodeText","Data":"特征引入："}]},{"ID":"20251010223620-db3lmkg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251010223620-db3lmkg","updated":"20251010223714"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::convert::TryInto;\nfn main() {\n  let a: i32 = 10;\n  let b: u16 = 100;\n\n  let b_ = b.try_into()  这里  等于let b_:i32  ，不写但是编译器通过下文推断if a \u003c b_也可以编译成功\n            .unwrap();\n\n  if a \u003c b_ {\n    println!(\"Ten is less than one hundred.\");\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251010223715-k067y61","Type":"NodeParagraph","Properties":{"id":"20251010223715-k067y61","updated":"20251010223715"}}]}