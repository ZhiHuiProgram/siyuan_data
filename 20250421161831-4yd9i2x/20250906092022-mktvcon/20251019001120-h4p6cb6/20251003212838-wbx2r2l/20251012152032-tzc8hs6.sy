{"ID":"20251012152032-tzc8hs6","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251012152032-tzc8hs6","title":"深入特征","type":"doc","updated":"20251028225815"},"Children":[{"ID":"20251022180242-hj8qpo2","Type":"NodeParagraph","Properties":{"id":"20251022180242-hj8qpo2","updated":"20251022180242"}},{"ID":"20251012152032-xuqwnz3","Type":"NodeParagraph","Properties":{"id":"20251012152032-xuqwnz3","updated":"20251012152236"},"Children":[{"Type":"NodeText","Data":"方法里面有说过关联函数：输入非self的函数"}]},{"ID":"20251012152134-0qjou36","Type":"NodeParagraph","Properties":{"id":"20251012152134-0qjou36","updated":"20251012152237"},"Children":[{"Type":"NodeText","Data":"关联类型："}]},{"ID":"20251012152240-jaozun3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012152240-jaozun3","updated":"20251012154224"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub trait Iterator {\n    type Item;  //自定义类型， 关联类型的写法\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012153920-h8u1hoe","Type":"NodeParagraph","Properties":{"id":"20251012153920-h8u1hoe","updated":"20251012163729"},"Children":[{"Type":"NodeText","Data":"例子"}]},{"ID":"20251012163729-bspobx8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012163729-bspobx8","updated":"20251013133722"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::ops::Add;\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {   Add源码可以看到定义pub trait Add\u003cRhs = Self\u003e   这里默认是同类型相加\n    type Output = Point;\n\n    fn add(self, other: Point) -\u003e Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}person\n\nfn main() {\n    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n               Point { x: 3, y: 3 });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012164751-wdyx4th","Type":"NodeParagraph","Properties":{"id":"20251012164751-wdyx4th","updated":"20251012164814"},"Children":[{"Type":"NodeText","Data":"为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Point"},{"Type":"NodeText","Data":"​ 结构体提供 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+"},{"Type":"NodeText","Data":"​ 的能力，这就是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运算符重载，Rust 并不支持创建自定义运算符，只有定义在 std::ops 中的运算符才能进行重载"}]},{"ID":"20251012165035-t7tqfrl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012165035-t7tqfrl","updated":"20251012171312"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"不同类型相加需要指定输入的类型\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add\u003cMeters\u003e for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -\u003e Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012165047-n6r3kii","Type":"NodeParagraph","Properties":{"id":"20251012165047-n6r3kii","updated":"20251012172005"},"Children":[{"Type":"NodeText","Data":"特征出现了同名类型："}]},{"ID":"20251012172006-00e6vcr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012172006-00e6vcr","updated":"20251012172047"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"trait Pilot {\n    fn fly(\u0026self);\n}\ntrait Wizard {\n    fn fly(\u0026self);\n}\nstruct Human;\nimpl Pilot for Human {\n    fn fly(\u0026self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\nimpl Wizard for Human {\n    fn fly(\u0026self) {\n        println!(\"Up!\");\n    }\n}\nimpl Human {\n    fn fly(\u0026self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\nfn main() {\n    let person = Human;\n    Pilot::fly(\u0026person); // 调用Pilot特征上的方法   //需要显示调用\n    Wizard::fly(\u0026person); // 调用Wizard特征上的方法 //\n    person.fly(); // 调用Human类型自身的方法\t\t //默认是自己实现的这个\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012172323-trmg0cn","Type":"NodeParagraph","Properties":{"id":"20251012172323-trmg0cn","updated":"20251012172434"},"Children":[{"Type":"NodeText","Data":"引入特征的关联函数："}]},{"ID":"20251012172435-czl25dp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012172435-czl25dp","updated":"20251012173855"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"trait Animal {\n    fn baby_name() -\u003e String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -\u003e String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -\u003e String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n\t//狗狗自己实现的\n    println!(\"A baby dog is called a {}\", Dog::baby_name()); \n\t//实现dog里面的animal的关联函数，完全限定语法\n\tprintln!(\"A baby dog is called a {}\", \u003cDog as Animal\u003e::baby_name());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012172439-w4kh5p2","Type":"NodeParagraph","Properties":{"id":"20251012172439-w4kh5p2","updated":"20251016221628"},"Children":[{"Type":"NodeText","Data":"特征定义中的约束：超特征"}]},{"ID":"20251012174415-xadloe6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012174415-xadloe6","updated":"20251016221630"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::fmt::Display;\n\ntrait OutlinePrint: Display {   \n    fn outline_print(\u0026self) {   //实现OutlinePrint必须要有Display\n        let output = self.to_string();  //要不然 不知道self有没有Display特征，这里to_string是Display特征用到的\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012183013-hmomiwt","Type":"NodeParagraph","Properties":{"id":"20251012183013-hmomiwt","updated":"20251012183027"},"Children":[{"Type":"NodeText","Data":"解决孤儿规则："}]},{"ID":"20251012183027-h2cbss4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251012183027-h2cbss4","updated":"20251026231216"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"//newtype  //有些繁琐，每次调用要先剥皮\n//将vec封装到sturct里，然后给struct impl Display\nuse std::fmt;\n\nstruct Wrapper(Vec\u003cString\u003e);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}   \n//deref  重定义Target后 ，实现deref会自动剥皮\nuse std::ops::Deref;\n\nimpl Deref for Wrapper {\n    type Target = Vec\u003cString\u003e;\n    \n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\n// 现在可以自动使用 Vec 的方法\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\")]);  //这里不会自动触发deref\n    \n    // ✅ 自动解引用，可以用 Vec 的方法\n    println!(\"{}\", w.len());        // 可以了   //在调用方法时，发现w没有len方法，自动触发deref\n    println!(\"{:?}\", w.get(0));     // 可以了\n    \n    // 但还是不能直接修改\n    // w.push(...);  // 还是不行，因为没有 DerefMut\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251012183030-1jqmlbb","Type":"NodeParagraph","Properties":{"id":"20251012183030-1jqmlbb","updated":"20251022180240"},"Children":[{"Type":"NodeText","Data":"闭包特征："}]},{"ID":"20251022180240-yp6bjuj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022180240-yp6bjuj","updated":"20251022180241"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"Fn(u32) -\u003e u32 是一个特征，用来表示 T 是一个闭包类型\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028225815-wxg8any","Type":"NodeParagraph","Properties":{"id":"20251028225815-wxg8any","updated":"20251028225815"}}]}