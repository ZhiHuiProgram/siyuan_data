{"ID":"20251013150557-sxwo09s","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251013150557-sxwo09s","title":"KV 存储 HashMap","type":"doc","updated":"20251014132528"},"Children":[{"ID":"20251013150557-m3ehcti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251013150557-m3ehcti","updated":"20251013151356"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"创建\n\tuse std::collections::HashMap;  //需要引用，不在prelude里面\n\tlet mut my_gems = HashMap::new();\n\tlet mut my_gems = HashMap::with_capacity(capacity)\n\tmy_gems.insert(\"红宝石\", 1);\n\tmy_gems.insert(\"蓝宝石\", 2);\n\tmy_gems.insert(\"河边捡的误以为是宝石的破石头\", 18);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251013151453-rmzzqcx","Type":"NodeParagraph","Properties":{"id":"20251013151453-rmzzqcx","updated":"20251014132528"},"Children":[{"Type":"NodeText","Data":"列表Vec遍历存储：无序遍历，输出是无序的"}]},{"ID":"20251013225939-u8xx8er","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251013225939-u8xx8er","updated":"20251013225955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    use std::collections::HashMap;\n\n    let teams_list = vec![\n        (\"中国队\".to_string(), 100),\n        (\"美国队\".to_string(), 10),\n        (\"日本队\".to_string(), 50),\n    ];\n\t//先将 Vec 转为迭代器，接着通过 collect 方法，将迭代器中的元素收集后，转成 HashMap\n    let teams_map: HashMap\u003c_,_\u003e = teams_list.into_iter().collect();\n    \n    println!(\"{:?}\",teams_map)\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251013230020-1vg89jn","Type":"NodeParagraph","Properties":{"id":"20251013230020-1vg89jn","updated":"20251013230620"},"Children":[{"Type":"NodeText","Data":"哈希所有权："}]},{"ID":"20251013230634-fj1b33n","Type":"NodeList","ListData":{},"Properties":{"id":"20251013230634-fj1b33n","updated":"20251013230640"},"Children":[{"ID":"20251013230634-2u6czaz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251013230634-2u6czaz","updated":"20251013230634"},"Children":[{"ID":"20251013230634-agjxkj8","Type":"NodeParagraph","Properties":{"id":"20251013230634-agjxkj8","updated":"20251013230634"},"Children":[{"Type":"NodeText","Data":"若类型实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Copy"},{"Type":"NodeText","Data":"​ 特征，该类型会被复制进 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​，因此无所谓所有权"}]}]},{"ID":"20251013230634-mz23a4v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251013230634-mz23a4v","updated":"20251013230634"},"Children":[{"ID":"20251013230634-dl8snxv","Type":"NodeParagraph","Properties":{"id":"20251013230634-dl8snxv","updated":"20251013230634"},"Children":[{"Type":"NodeText","Data":"若没实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Copy"},{"Type":"NodeText","Data":"​ 特征，所有权将被转移给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​ 中"}]}]},{"ID":"20251013230640-0ysyf24","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251013230640-0ysyf24","updated":"20251013230640"},"Children":[{"ID":"20251013230640-pjc89z8","Type":"NodeParagraph","Properties":{"id":"20251013230640-pjc89z8","updated":"20251013230640"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果你使用引用类型放入 HashMap 中"},{"Type":"NodeText","Data":"，请确保该引用的生命周期至少跟 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​ 活得一样久"}]}]}]},{"ID":"20251013230642-lsmj6rb","Type":"NodeParagraph","Properties":{"id":"20251013230642-lsmj6rb","updated":"20251014095138"},"Children":[{"Type":"NodeText","Data":"查询HashMap"}]},{"ID":"20251014095139-lfuveyb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251014095139-lfuveyb","updated":"20251014103528"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nlet team_name = String::from(\"Blue\");\nlet score: Option\u003c\u0026i32\u003e = scores.get(\u0026team_name);  //get的键只能是借用， Option的值，如果不是借用可能会发生所有权转移，get返回的是Option枚举\n//下面是get源码\nimpl\u003cK, V\u003e HashMap\u003cK, V\u003e\nwhere\n    K: Eq + Hash,\n{\n    pub fn get\u003cQ\u003e(\u0026self, k: \u0026Q) -\u003e Option\u003c\u0026V\u003e \n    where\n        K: Borrow\u003cQ\u003e,   //约束，K只能是Borrow借用\n        Q: Hash + Eq + ?Sized,\n    { ... }\n}\n\n//如果想直接获取值呢\nlet score: i32 = scores.get(\u0026team_name).copied().unwrap_or(0);\n这里：\n\tget返回的是借用，所以如果想拥有所有权，需要copied（）；\n\t如果想从返回的Some（T）中取值，调用\n\t\t\t\t\tunwrap_or（0）  必须设定默认值，如果为NONE返回默认值\n\t\t\t\t\tunwrap_or_default（）；方法一样，但是如果是None默认是0\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251014103309-o2j4ue5","Type":"NodeParagraph","Properties":{"id":"20251014103309-o2j4ue5","updated":"20251014103545"},"Children":[{"Type":"NodeText","Data":"取值："}]},{"ID":"20251014103546-hhb0vhn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251014103546-hhb0vhn","updated":"20251014103609"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"for (key, value) in \u0026scores {\n    println!(\"{}: {}\", key, value);\n}  迭代器返回的是元组类型，进行元组解构\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251014103553-z2315m4","Type":"NodeParagraph","Properties":{"id":"20251014103553-z2315m4","updated":"20251014114341"},"Children":[{"Type":"NodeText","Data":"修改值："}]},{"ID":"20251014114341-es9qpge","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251014114341-es9qpge","updated":"20251014131145"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::collections::HashMap;\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);\nlet v = scores.entry(\"Yellow\").or_insert(5); \nscores.entry(\"Blue\").and_modify(|v| *v += 1).or_insert(0);  //and_modify这里也是判断，然后存在则修改值，返回引用。不存在返回entry\n //entry会返回一个Entry 枚举，然后根据枚举or_insert判断有无值，进行插入然后返回当前值或插入值引用\n\tenum Entry\u003cK, V\u003e {\n    \tOccupied(已存在的值),  // 有值\n    \tVacant(空位),          // 没值\n\t}\n//例子\nlet text = \"hello world wonderful world\";\n\nlet mut map = HashMap::new();\n// 根据空格来切分字符串(英文单词都是通过空格切分)\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\nor_insert 返回了 \u0026mut v 引用，因此可以通过该可变引用直接修改 map 中对应的值\n使用 count 引用时，需要先进行解引用 *count，否则会出现类型不匹配\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251014114414-g5a5tsx","Type":"NodeParagraph","Properties":{"id":"20251014114414-g5a5tsx","updated":"20251014132205"},"Children":[{"Type":"NodeText","Data":"哈希函数："}]},{"ID":"20251014132059-1j2cwmx","Type":"NodeParagraph","Properties":{"id":"20251014132059-1j2cwmx","updated":"20251014132108"},"Children":[{"Type":"NodeText","Data":"若性能测试显示当前标准库默认的哈希函数不能满足你的性能需求，就需要去 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://crates.io/","TextMarkTextContent":"crates.io"},{"Type":"NodeText","Data":"​ 上寻找其它的哈希函数实现，使用方法很简单："}]},{"ID":"20251014132112-nl5h1qm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251014132112-nl5h1qm","updated":"20251014132113"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::hash::BuildHasherDefault;\nuse std::collections::HashMap;\n// 引入第三方的哈希函数\nuse twox_hash::XxHash64;\n\n// 指定HashMap使用第三方的哈希函数XxHash64\nlet mut hash: HashMap\u003c_, _, BuildHasherDefault\u003cXxHash64\u003e\u003e = Default::default();\nhash.insert(42, \"the answer\");\nassert_eq!(hash.get(\u002642), Some(\u0026\"the answer\"));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251014132119-87q9sg5","Type":"NodeParagraph","Properties":{"id":"20251014132119-87q9sg5","updated":"20251014132119"},"Children":[{"Type":"NodeText","Data":"目前，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​ 使用的哈希函数是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SipHash"},{"Type":"NodeText","Data":"​，它的性能不是很高，但是安全性很高。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"SipHash"},{"Type":"NodeText","Data":"​ 在中等大小的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Key"},{"Type":"NodeText","Data":"​ 上，性能相当不错，但是对于小型的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Key"},{"Type":"NodeText","Data":"​ （例如整数）或者大型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Key"},{"Type":"NodeText","Data":"​ （例如字符串）来说，性能还是不够好。若你需要极致性能，例如实现算法，可以考虑这个库："},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://github.com/tkaitchuck/ahash","TextMarkTextContent":"ahash"},{"Type":"NodeText","Data":"。"}]},{"ID":"20251014132206-498m5fb","Type":"NodeParagraph","Properties":{"id":"20251014132206-498m5fb","updated":"20251014132206"}}]}