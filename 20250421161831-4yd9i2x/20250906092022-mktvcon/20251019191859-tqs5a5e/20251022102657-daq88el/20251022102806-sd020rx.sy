{"ID":"20251022102806-sd020rx","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251022102806-sd020rx","title":"闭包 Closure","type":"doc","updated":"20251114230336"},"Children":[{"ID":"20251023152432-b9rhzj9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023152432-b9rhzj9","updated":"20251023230745"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC","TextMarkTextContent":"捕获作用域中的值"}]},{"ID":"20251023152434-pz2mcln","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023152434-pz2mcln","updated":"20251023230745"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"就算签名一样的闭包，类型也是不同的\n不支持显示生命周期标注，因为是根据上下文推断\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023211917-zf62xvu","Type":"NodeParagraph","Properties":{"id":"20251023211917-zf62xvu","updated":"20251023211917"}},{"ID":"20251022102806-ng5b4go","Type":"NodeParagraph","Properties":{"id":"20251022102806-ng5b4go","updated":"20251022103038"},"Children":[{"Type":"NodeText","Data":"闭包是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值"}]},{"ID":"20251022103038-nlbi0xj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022103038-nlbi0xj","updated":"20251022103321"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n   let x = 1;\n   let sum = |y| x + y;  //可以赋值给变量，允许捕获调用者作用域中的值\n\n    assert_eq!(3, sum(2));  //sum 被赋值为了函数\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022103042-wxi0f3k","Type":"NodeParagraph","Properties":{"id":"20251022103042-wxi0f3k","updated":"20251022172926"},"Children":[{"Type":"NodeText","Data":"类似函数指针"}]},{"ID":"20251022172927-wgja3n1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022172927-wgja3n1","updated":"20251022172957"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn muuuuu(intensity: u32) -\u003e u32 {\n    println!(\"muuuu.....\");\n    thread::sleep(Duration::from_secs(2));\n    intensity\n}\nlet action = muuuuu;\naction(intensity)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022172958-3wvsv5c","Type":"NodeParagraph","Properties":{"id":"20251022172958-3wvsv5c","updated":"20251022173006"},"Children":[{"Type":"NodeText","Data":"上面的那个进行闭包替换"}]},{"ID":"20251022173007-v94wu2n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022173007-v94wu2n","updated":"20251022173731"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"\tlet action = || {\n        println!(\"muuuu.....\");\n        thread::sleep(Duration::from_secs(2));\n        intensity\n    };\n\taction();\n方法：\n\tlet mut x = 1;\n    let closure = |x: \u0026mut i32| {*x= *x + 1; *x};\n    println!(\"{}\", closure(\u0026mut x));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022180056-skz6xco","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251022180056-skz6xco","updated":"20251023212109"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85","TextMarkTextContent":"结构体中的闭包"}]},{"ID":"20251022180057-m2q7e8o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022180057-m2q7e8o","updated":"20251022181432"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Cacher\u003cT\u003e\nwhere\n    T: Fn(u32) -\u003e u32,\n{\n    query: T,\n    value: Option\u003cu32\u003e,\n}\nFn(u32) -\u003e u32 是一个特征，用来表示 T 是一个闭包类型，同样适用于函数\n\n调用的时候： (test.query)(x:i32)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212235-wo8nyec","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023212235-wo8nyec","updated":"20251023212531"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC","TextMarkTextContent":"捕获作用域中的值"}]},{"ID":"20251023212235-8m2rp73","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212235-8m2rp73","updated":"20251023212342"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"    let x = 4;\n    let equal_to_x = |z| z == x;\n    let y = 4;\n\tassert!(equal_to_x(y));\n\n函数则不能捕获作用域的值\n    let x = 4;\n    fn equal_to_x(z: i32) -\u003e bool {\n        z == x\n    }\n    let y = 4;\n\tassert!(equal_to_x(y));  //禁止的，不能用\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212520-46undps","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251023212520-46undps","updated":"20251023212531"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E9%97%AD%E5%8C%85%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D","TextMarkTextContent":"闭包对内存的影响"}]},{"ID":"20251023212521-92nd5yh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212521-92nd5yh","linewrap":"true","updated":"20251023212527"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212535-otvmycv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251023212535-otvmycv","updated":"20251023224326"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%89%B9%E5%BE%81","TextMarkTextContent":"三种 Fn 特征"}]},{"ID":"20251023215323-xd2xqog","Type":"NodeParagraph","Properties":{"id":"20251023215323-xd2xqog","updated":"20251023215759"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FnOnce"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251023212536-xuaisxi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212536-xuaisxi","updated":"20251023215738"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用\n\nFnOnce：\n\tfn fn_once\u003cF\u003e(func: F)\n\twhere\n\t    F: FnOnce(usize) -\u003e bool,\n\t{\n\t    println!(\"{}\", func(3));\n\t    println!(\"{}\", func(4));  这里func被声明为FnOnce类型，所以使用第一次时所有权已经被转移了，注意是func的所有权，所以func只能使用一次\n\n\t}\n\t\n\tfn main() {\n\t    let x = vec![1, 2, 3];\n\t    fn_once(|z|{z == x.len()})\n\t}\n\t--------------------------------\n\t上面的例子可以解决\n\tfn fn_once\u003cF\u003e(func: F)\n\twhere\n\t    F: FnOnce(usize) -\u003e bool + Copy,// 改动在这里，增加一个copy特征\n\t--------------------------------\nmove\t线程传入闭包，或者返回闭包，这时捕获的值生命周期就小于闭包了\n\tuse std::thread;\n\tlet v = vec![1, 2, 3];\n\tlet handle = thread::spawn(move || {   //闭包前加move会转移参数的所有权\n\t    println!(\"Here's a vector: {:?}\", v);\n\t});\n\thandle.join().unwrap();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023215326-3phyh8m","Type":"NodeParagraph","Properties":{"id":"20251023215326-3phyh8m","updated":"20251023215748"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FnMut"},{"Type":"NodeText","Data":"​："}]},{"ID":"20251023215748-r9otnwb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023215748-r9otnwb","linewrap":"true","updated":"20251023223950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"它以可变借用的方式捕获了环境中的值，因此可以修改该值：\n\tfn main() {\n\t    let mut s = String::new();\n\t\n\t    //let update_string =  |str| s.push_str(str);   //错误，捕获了外界却改值了\n\t\tlet mut update_string =  |str| s.push_str(str);  //增加mut  可以修改捕获的作用域值\n\t\t//如果你忽略 update_string 的类型，仅仅把它当成一个普通变量，那么这种声明就比较合理了\n\t    update_string(\"hello\");\n\t\n\t    println!(\"{:?}\",s);\n\t}\n\t这里：闭包修改了 s（通过 push_str），所以它实现的是 FnMut trait\n\tFnMut 闭包在调用时需要 \u0026mut self\n\t所以 update_string 变量本身必须是可变的\n复杂一点的例子：\n\tfn main() {\n\t    let mut s = String::new();\n\t\n\t    let update_string =  |str| s.push_str(str);\n\t\n\t    exec(update_string);  //这里调用就没问题，因为函数参数已经调用的是mut f了，传入的是FnMut，有点抽象，用多了就好了\n\t\t//exec(update_string);  //不可以调用第二次，所有权没了\n\t    println!(\"{:?}\",s);\n\t}\n\t\n\tfn exec\u003c'a, F: FnMut(\u0026'a str)\u003e(mut f: F)  {\n\t    f(\"hello\")\n\t}\n\t这里update_string一定是一个可变类型的闭包\n\t自动标注是let update_string: impl FnMut(\u0026str) =  |str| s.push_str(str);\n首先创建了一个可变的字符串s，然后定义了一个可变类型闭包update_string，该闭包接受一个字符串参数并将其追加到s中。接下来调用了exec函数，并将update_string闭包的所有权移交给它。最后打印出了字符串s的内容。\nupdate_string闭包的所有权被移交给了exec函数。这说明update_string没有实现Copy特征，但并不是所有闭包都没有实现Copy特征，闭包自动实现Copy特征的规则是，只要闭包捕获的类型都实现了Copy特征的话，这个闭包就会默认实现Copy特征。\n\t// 拿所有权\n\tlet s = String::new();\n\tlet update_string = move || println!(\"{}\", s);\n\t\n\texec(update_string);\n\t// exec2(update_string); // 不能再用了\n\t\n\t// 可变引用\n\tlet mut s = String::new();\n\tlet mut update_string = || s.push_str(\"hello\");\n\texec(update_string);\n\t// exec1(update_string); // 不能再用了\n\t刚刚的代码就属于第二类，取得的是s的可变引用，没有实现Copy。  如果是i32或者其他有copy特征的则可以实现多次\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023220413-xadtcua","Type":"NodeParagraph","Properties":{"id":"20251023220413-xadtcua","updated":"20251023224002"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Fn"},{"Type":"NodeText","Data":"​："}]},{"ID":"20251023224002-l44t6ud","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224002-l44t6ud","updated":"20251023224057"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"它以不可变借用的方式捕获环境中的值 ，比较好理解，闭包里面不能改捕获的值\nfn main() {\n    let mut s = String::new();\n\n    let update_string =  |str| s.push_str(str);  //错了\n\n    exec(update_string);\n\n    println!(\"{:?}\",s);\n}\n\nfn exec\u003c'a, F: Fn(\u0026'a str)\u003e(mut f: F)  {\n    f(\"hello\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023224213-jnqgm25","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251023224213-jnqgm25","updated":"20251023224326"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#move-%E5%92%8C-fn","TextMarkTextContent":"move 和 Fn"}]},{"ID":"20251023224214-23w89ae","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224214-23w89ae","updated":"20251023224326"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。move 本身强调的就是后者，闭包如何捕获变量：\nfn main() {\n    let s = String::new();\n\n    let update_string =  move || println!(\"{}\",s);\n\n    exec(update_string);\n}\n\nfn exec\u003cF: FnOnce()\u003e(f: F)  {   //都可以\n    f()\n}\nfn exec\u003cF: Fn()\u003e(f: F)  {\n    f()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023224823-n22am14","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251023224823-n22am14","updated":"20251023225204"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%9A%84%E5%85%B3%E7%B3%BB","TextMarkTextContent":"三种 Fn 的关系"}]},{"ID":"20251023224824-y2l7498","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224824-y2l7498","updated":"20251023225204"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"1.所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次\n2.没有移出所捕获变量的所有权的闭包自动实现了 FnMut 特征\n3.不需要对捕获变量进行改变的闭包自动实现了 Fn 特征\n\tfn main() {\n\t    let s = String::new();\n\t\n\t    let update_string =  || println!(\"{}\",s);\n\t\n\t    exec(update_string);\n\t    exec1(update_string);\n\t    exec2(update_string);\n\t}\n\t\n\tfn exec\u003cF: FnOnce()\u003e(f: F)  {\n\t    f()\n\t}\n\t\n\tfn exec1\u003cF: FnMut()\u003e(mut f: F)  {\n\t    f()\n\t}\n\t\n\tfn exec2\u003cF: Fn()\u003e(f: F)  {\n\t    f()\n\t}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023225208-j1fu484","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023225208-j1fu484","updated":"20251023230301"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC","TextMarkTextContent":"闭包作为函数返回值"}]},{"ID":"20251023225208-0rgi6yj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023225208-0rgi6yj","updated":"20251023230301"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn factory(x:i32) -\u003e impl Fn(i32) -\u003e i32 {  //这里要用impl，因为编译器判断返回值要明确空间大小，类型，因为特征类似接口\n\n    let num = 5;\n\n    if x \u003e 1{  //错咯，签名一样的闭包，类型也是不同的，返回的两个分支是两个类型\n        move |x| x + num\n    } else {\n        move |x| x - num\n    }\n}\n|\n|\n|\nv\nfn factory(x:i32) -\u003e Box\u003cdyn Fn(i32) -\u003e i32\u003e {   返回一个特征对象\n    let num = 5;\n\n    if x \u003e 1{\n        Box::new(move |x| x + num)\n    } else {\n        Box::new(move |x| x - num)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251114230101-b80i3x6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251114230101-b80i3x6","updated":"20251114230148"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%93%E6%9D%9F%E7%9A%84","TextMarkTextContent":"线程是如何结束的"}]},{"ID":"20251114230146-2ptv8jv","Type":"NodeParagraph","Properties":{"id":"20251114230146-2ptv8jv","updated":"20251114230146"},"Children":[{"Type":"NodeText","Data":"线程的代码执行完，线程就会自动结束。"}]},{"ID":"20251114230146-mdlfabf","Type":"NodeParagraph","Properties":{"id":"20251114230146-mdlfabf","updated":"20251114230146"},"Children":[{"Type":"NodeText","Data":"如果线程中的代码不会执行完呢？"}]},{"ID":"20251114230138-th61j2o","Type":"NodeList","ListData":{},"Properties":{"id":"20251114230138-th61j2o","updated":"20251114230138"},"Children":[{"ID":"20251114230138-m1jemmk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230138-m1jemmk","updated":"20251114230138"},"Children":[{"ID":"20251114230138-ldo96fp","Type":"NodeParagraph","Properties":{"id":"20251114230138-ldo96fp","updated":"20251114230138"},"Children":[{"Type":"NodeText","Data":"线程的任务是一个循环 IO 读取，任务流程类似：IO 阻塞，等待读取新的数据 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 读到数据，处理完成 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 继续阻塞等待 ··· -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 收到 socket 关闭的信号 -"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 结束线程，在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU 占用其实很小，也是网络服务中最最常见的模型"}]}]},{"ID":"20251114230138-miy5toc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230138-miy5toc","updated":"20251114230138"},"Children":[{"ID":"20251114230138-2i0xyww","Type":"NodeParagraph","Properties":{"id":"20251114230138-2i0xyww","updated":"20251114230138"},"Children":[{"Type":"NodeText","Data":"线程的任务是一个循环，里面没有任何阻塞，包括休眠这种操作也没有，此时 CPU 很不幸的会被跑满，而且你如果没有设置终止条件，该线程将持续跑满一个 CPU 核心，并且不会被终止，直到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"main"},{"Type":"NodeText","Data":"​ 线程的结束"}]}]}]},{"ID":"20251114230205-ccanng0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251114230205-ccanng0","updated":"20251114230221"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD","TextMarkTextContent":"多线程的性能"}]},{"ID":"20251114230212-vg7ej8q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251114230212-vg7ej8q","updated":"20251114230221"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD","TextMarkTextContent":"创建线程的性能"}]},{"ID":"20251114230214-1jxw0nz","Type":"NodeParagraph","Properties":{"id":"20251114230214-1jxw0nz","updated":"20251114230221"},"Children":[{"Type":"NodeText","Data":"据不精确估算，创建一个线程大概需要 0.24 毫秒，随着线程的变多，这个值会变得更大，因此线程的创建耗时是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程，一些鸡毛蒜皮的任务，就无需创建线程了。"}]},{"ID":"20251114230225-eu54cwj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251114230225-eu54cwj","updated":"20251114230304"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82","TextMarkTextContent":"创建多少线程合适"}]},{"ID":"20251114230225-49r6ojk","Type":"NodeParagraph","Properties":{"id":"20251114230225-49r6ojk","updated":"20251114230240"},"Children":[{"Type":"NodeText","Data":"因为 CPU 的核心数限制，当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能，因为每个线程的任务都可以轻松让 CPU 的某个核心跑满，既然如此，让线程数等于 CPU 核心数是最好的。"}]},{"ID":"20251114230252-paoooh4","Type":"NodeParagraph","Properties":{"id":"20251114230252-paoooh4","updated":"20251114230252"},"Children":[{"Type":"NodeText","Data":"过多的线程也会导致线程上下文切换的代价过大，使用 async/await 的 M:N 并发模型，就没有这个烦恼。"}]},{"ID":"20251114230304-dy0r6nk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251114230304-dy0r6nk","updated":"20251114230336"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80","TextMarkTextContent":"多线程的开销"}]},{"ID":"20251114230326-ho70aef","Type":"NodeParagraph","Properties":{"id":"20251114230326-ho70aef","updated":"20251114230326"},"Children":[{"Type":"NodeText","Data":"无锁实现(CAS)的 Hashmap 在多线程下的使用"}]},{"ID":"20251114230332-7nfa1de","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251114230332-7nfa1de","updated":"20251114230335"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"for i in 0..num_threads {\n    let ht = Arc::clone(\u0026ht);\n\n    let handle = thread::spawn(move || {\n        for j in 0..adds_per_thread {\n            let key = thread_rng().gen::\u003cu32\u003e();\n            let value = thread_rng().gen::\u003cu32\u003e();\n            ht.set_item(key, value);\n        }\n    });\n\n    handles.push(handle);\n}\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251114230315-hm6nzpn","Type":"NodeList","ListData":{},"Properties":{"id":"20251114230315-hm6nzpn","updated":"20251114230315"},"Children":[{"ID":"20251114230315-znwbvgw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230315-znwbvgw","updated":"20251114230315"},"Children":[{"ID":"20251114230315-ppxo9ir","Type":"NodeParagraph","Properties":{"id":"20251114230315-ppxo9ir","updated":"20251114230315"},"Children":[{"Type":"NodeText","Data":"虽然是无锁，但是内部是 CAS 实现，大量线程的同时访问，会让 CAS 重试次数大幅增加"}]}]},{"ID":"20251114230315-rp3k0x5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230315-rp3k0x5","updated":"20251114230315"},"Children":[{"ID":"20251114230315-ztqglux","Type":"NodeParagraph","Properties":{"id":"20251114230315-ztqglux","updated":"20251114230315"},"Children":[{"Type":"NodeText","Data":"线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU Cache-line 的情况也会经常发生"}]}]},{"ID":"20251114230315-nf6kgyz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230315-nf6kgyz","updated":"20251114230315"},"Children":[{"ID":"20251114230315-0k15qob","Type":"NodeParagraph","Properties":{"id":"20251114230315-0k15qob","updated":"20251114230315"},"Children":[{"Type":"NodeText","Data":"大量读写可能会让内存带宽也成为瓶颈"}]}]},{"ID":"20251114230315-k2240mt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251114230315-k2240mt","updated":"20251114230315"},"Children":[{"ID":"20251114230315-a45y3d7","Type":"NodeParagraph","Properties":{"id":"20251114230315-a45y3d7","updated":"20251114230315"},"Children":[{"Type":"NodeText","Data":"读和写不一样，无锁数据结构的读往往可以很好地线性增长，但是写不行，因为写竞争太大"}]}]}]},{"ID":"20251114230336-pd2tp6s","Type":"NodeParagraph","Properties":{"id":"20251114230336-pd2tp6s","updated":"20251114230336"}}]}