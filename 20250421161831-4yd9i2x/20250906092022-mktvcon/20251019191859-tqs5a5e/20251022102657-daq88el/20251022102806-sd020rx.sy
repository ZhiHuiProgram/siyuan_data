{"ID":"20251022102806-sd020rx","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251022102806-sd020rx","title":"闭包 Closure","type":"doc","updated":"20251023230745"},"Children":[{"ID":"20251023152432-b9rhzj9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023152432-b9rhzj9","updated":"20251023230745"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC","TextMarkTextContent":"捕获作用域中的值"}]},{"ID":"20251023152434-pz2mcln","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023152434-pz2mcln","updated":"20251023230745"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"就算签名一样的闭包，类型也是不同的\n不支持显示生命周期标注，因为是根据上下文推断\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023211917-zf62xvu","Type":"NodeParagraph","Properties":{"id":"20251023211917-zf62xvu","updated":"20251023211917"}},{"ID":"20251022102806-ng5b4go","Type":"NodeParagraph","Properties":{"id":"20251022102806-ng5b4go","updated":"20251022103038"},"Children":[{"Type":"NodeText","Data":"闭包是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值"}]},{"ID":"20251022103038-nlbi0xj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022103038-nlbi0xj","updated":"20251022103321"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n   let x = 1;\n   let sum = |y| x + y;  //可以赋值给变量，允许捕获调用者作用域中的值\n\n    assert_eq!(3, sum(2));  //sum 被赋值为了函数\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022103042-wxi0f3k","Type":"NodeParagraph","Properties":{"id":"20251022103042-wxi0f3k","updated":"20251022172926"},"Children":[{"Type":"NodeText","Data":"类似函数指针"}]},{"ID":"20251022172927-wgja3n1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022172927-wgja3n1","updated":"20251022172957"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn muuuuu(intensity: u32) -\u003e u32 {\n    println!(\"muuuu.....\");\n    thread::sleep(Duration::from_secs(2));\n    intensity\n}\nlet action = muuuuu;\naction(intensity)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022172958-3wvsv5c","Type":"NodeParagraph","Properties":{"id":"20251022172958-3wvsv5c","updated":"20251022173006"},"Children":[{"Type":"NodeText","Data":"上面的那个进行闭包替换"}]},{"ID":"20251022173007-v94wu2n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022173007-v94wu2n","updated":"20251022173731"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"\tlet action = || {\n        println!(\"muuuu.....\");\n        thread::sleep(Duration::from_secs(2));\n        intensity\n    };\n\taction();\n方法：\n\tlet mut x = 1;\n    let closure = |x: \u0026mut i32| {*x= *x + 1; *x};\n    println!(\"{}\", closure(\u0026mut x));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251022180056-skz6xco","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251022180056-skz6xco","updated":"20251023212109"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85","TextMarkTextContent":"结构体中的闭包"}]},{"ID":"20251022180057-m2q7e8o","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251022180057-m2q7e8o","updated":"20251022181432"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Cacher\u003cT\u003e\nwhere\n    T: Fn(u32) -\u003e u32,\n{\n    query: T,\n    value: Option\u003cu32\u003e,\n}\nFn(u32) -\u003e u32 是一个特征，用来表示 T 是一个闭包类型，同样适用于函数\n\n调用的时候： (test.query)(x:i32)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212235-wo8nyec","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023212235-wo8nyec","updated":"20251023212531"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC","TextMarkTextContent":"捕获作用域中的值"}]},{"ID":"20251023212235-8m2rp73","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212235-8m2rp73","updated":"20251023212342"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"    let x = 4;\n    let equal_to_x = |z| z == x;\n    let y = 4;\n\tassert!(equal_to_x(y));\n\n函数则不能捕获作用域的值\n    let x = 4;\n    fn equal_to_x(z: i32) -\u003e bool {\n        z == x\n    }\n    let y = 4;\n\tassert!(equal_to_x(y));  //禁止的，不能用\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212520-46undps","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251023212520-46undps","updated":"20251023212531"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E9%97%AD%E5%8C%85%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D","TextMarkTextContent":"闭包对内存的影响"}]},{"ID":"20251023212521-92nd5yh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212521-92nd5yh","linewrap":"true","updated":"20251023212527"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023212535-otvmycv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251023212535-otvmycv","updated":"20251023224326"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%89%B9%E5%BE%81","TextMarkTextContent":"三种 Fn 特征"}]},{"ID":"20251023215323-xd2xqog","Type":"NodeParagraph","Properties":{"id":"20251023215323-xd2xqog","updated":"20251023215759"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FnOnce"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251023212536-xuaisxi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023212536-xuaisxi","updated":"20251023215738"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用\n\nFnOnce：\n\tfn fn_once\u003cF\u003e(func: F)\n\twhere\n\t    F: FnOnce(usize) -\u003e bool,\n\t{\n\t    println!(\"{}\", func(3));\n\t    println!(\"{}\", func(4));  这里func被声明为FnOnce类型，所以使用第一次时所有权已经被转移了，注意是func的所有权，所以func只能使用一次\n\n\t}\n\t\n\tfn main() {\n\t    let x = vec![1, 2, 3];\n\t    fn_once(|z|{z == x.len()})\n\t}\n\t--------------------------------\n\t上面的例子可以解决\n\tfn fn_once\u003cF\u003e(func: F)\n\twhere\n\t    F: FnOnce(usize) -\u003e bool + Copy,// 改动在这里，增加一个copy特征\n\t--------------------------------\nmove\t线程传入闭包，或者返回闭包，这时捕获的值生命周期就小于闭包了\n\tuse std::thread;\n\tlet v = vec![1, 2, 3];\n\tlet handle = thread::spawn(move || {   //闭包前加move会转移参数的所有权\n\t    println!(\"Here's a vector: {:?}\", v);\n\t});\n\thandle.join().unwrap();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023215326-3phyh8m","Type":"NodeParagraph","Properties":{"id":"20251023215326-3phyh8m","updated":"20251023215748"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"FnMut"},{"Type":"NodeText","Data":"​："}]},{"ID":"20251023215748-r9otnwb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023215748-r9otnwb","linewrap":"true","updated":"20251023223950"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"它以可变借用的方式捕获了环境中的值，因此可以修改该值：\n\tfn main() {\n\t    let mut s = String::new();\n\t\n\t    //let update_string =  |str| s.push_str(str);   //错误，捕获了外界却改值了\n\t\tlet mut update_string =  |str| s.push_str(str);  //增加mut  可以修改捕获的作用域值\n\t\t//如果你忽略 update_string 的类型，仅仅把它当成一个普通变量，那么这种声明就比较合理了\n\t    update_string(\"hello\");\n\t\n\t    println!(\"{:?}\",s);\n\t}\n\t这里：闭包修改了 s（通过 push_str），所以它实现的是 FnMut trait\n\tFnMut 闭包在调用时需要 \u0026mut self\n\t所以 update_string 变量本身必须是可变的\n复杂一点的例子：\n\tfn main() {\n\t    let mut s = String::new();\n\t\n\t    let update_string =  |str| s.push_str(str);\n\t\n\t    exec(update_string);  //这里调用就没问题，因为函数参数已经调用的是mut f了，传入的是FnMut，有点抽象，用多了就好了\n\t\t//exec(update_string);  //不可以调用第二次，所有权没了\n\t    println!(\"{:?}\",s);\n\t}\n\t\n\tfn exec\u003c'a, F: FnMut(\u0026'a str)\u003e(mut f: F)  {\n\t    f(\"hello\")\n\t}\n\t这里update_string一定是一个可变类型的闭包\n\t自动标注是let update_string: impl FnMut(\u0026str) =  |str| s.push_str(str);\n首先创建了一个可变的字符串s，然后定义了一个可变类型闭包update_string，该闭包接受一个字符串参数并将其追加到s中。接下来调用了exec函数，并将update_string闭包的所有权移交给它。最后打印出了字符串s的内容。\nupdate_string闭包的所有权被移交给了exec函数。这说明update_string没有实现Copy特征，但并不是所有闭包都没有实现Copy特征，闭包自动实现Copy特征的规则是，只要闭包捕获的类型都实现了Copy特征的话，这个闭包就会默认实现Copy特征。\n\t// 拿所有权\n\tlet s = String::new();\n\tlet update_string = move || println!(\"{}\", s);\n\t\n\texec(update_string);\n\t// exec2(update_string); // 不能再用了\n\t\n\t// 可变引用\n\tlet mut s = String::new();\n\tlet mut update_string = || s.push_str(\"hello\");\n\texec(update_string);\n\t// exec1(update_string); // 不能再用了\n\t刚刚的代码就属于第二类，取得的是s的可变引用，没有实现Copy。  如果是i32或者其他有copy特征的则可以实现多次\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023220413-xadtcua","Type":"NodeParagraph","Properties":{"id":"20251023220413-xadtcua","updated":"20251023224002"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Fn"},{"Type":"NodeText","Data":"​："}]},{"ID":"20251023224002-l44t6ud","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224002-l44t6ud","updated":"20251023224057"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"它以不可变借用的方式捕获环境中的值 ，比较好理解，闭包里面不能改捕获的值\nfn main() {\n    let mut s = String::new();\n\n    let update_string =  |str| s.push_str(str);  //错了\n\n    exec(update_string);\n\n    println!(\"{:?}\",s);\n}\n\nfn exec\u003c'a, F: Fn(\u0026'a str)\u003e(mut f: F)  {\n    f(\"hello\")\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023224213-jnqgm25","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251023224213-jnqgm25","updated":"20251023224326"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#move-%E5%92%8C-fn","TextMarkTextContent":"move 和 Fn"}]},{"ID":"20251023224214-23w89ae","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224214-23w89ae","updated":"20251023224326"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。move 本身强调的就是后者，闭包如何捕获变量：\nfn main() {\n    let s = String::new();\n\n    let update_string =  move || println!(\"{}\",s);\n\n    exec(update_string);\n}\n\nfn exec\u003cF: FnOnce()\u003e(f: F)  {   //都可以\n    f()\n}\nfn exec\u003cF: Fn()\u003e(f: F)  {\n    f()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023224823-n22am14","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251023224823-n22am14","updated":"20251023225204"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E4%B8%89%E7%A7%8D-fn-%E7%9A%84%E5%85%B3%E7%B3%BB","TextMarkTextContent":"三种 Fn 的关系"}]},{"ID":"20251023224824-y2l7498","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023224824-y2l7498","updated":"20251023225204"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"1.所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次\n2.没有移出所捕获变量的所有权的闭包自动实现了 FnMut 特征\n3.不需要对捕获变量进行改变的闭包自动实现了 Fn 特征\n\tfn main() {\n\t    let s = String::new();\n\t\n\t    let update_string =  || println!(\"{}\",s);\n\t\n\t    exec(update_string);\n\t    exec1(update_string);\n\t    exec2(update_string);\n\t}\n\t\n\tfn exec\u003cF: FnOnce()\u003e(f: F)  {\n\t    f()\n\t}\n\t\n\tfn exec1\u003cF: FnMut()\u003e(mut f: F)  {\n\t    f()\n\t}\n\t\n\tfn exec2\u003cF: Fn()\u003e(f: F)  {\n\t    f()\n\t}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023225208-j1fu484","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023225208-j1fu484","updated":"20251023230301"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/closure.html#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC","TextMarkTextContent":"闭包作为函数返回值"}]},{"ID":"20251023225208-0rgi6yj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023225208-0rgi6yj","updated":"20251023230301"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn factory(x:i32) -\u003e impl Fn(i32) -\u003e i32 {  //这里要用impl，因为编译器判断返回值要明确空间大小，类型，因为特征类似接口\n\n    let num = 5;\n\n    if x \u003e 1{  //错咯，签名一样的闭包，类型也是不同的，返回的两个分支是两个类型\n        move |x| x + num\n    } else {\n        move |x| x - num\n    }\n}\n|\n|\n|\nv\nfn factory(x:i32) -\u003e Box\u003cdyn Fn(i32) -\u003e i32\u003e {   返回一个特征对象\n    let num = 5;\n\n    if x \u003e 1{\n        Box::new(move |x| x + num)\n    } else {\n        Box::new(move |x| x - num)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023230107-ds2k0ui","Type":"NodeParagraph","Properties":{"id":"20251023230107-ds2k0ui","updated":"20251023230107"}}]}