{"ID":"20251022102742-i96qnmf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251022102742-i96qnmf","title":"迭代器 Iterator","type":"doc","updated":"20251024230955"},"Children":[{"ID":"20251023230819-62c7jvt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023230819-62c7jvt","updated":"20251024145935"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#for-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8","TextMarkTextContent":"For 循环与迭代器"}]},{"ID":"20251023230820-epj8adh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023230820-epj8adh","updated":"20251024145709"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"迭代器跟 for 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：是否通过索引来访问集合。\nlet arr = [1, 2, 3];\nfor (let i = 0; i \u003c arr.length; i++) {\n  console.log(arr[i]);\n}\nlet arr = [1, 2, 3];\nfor v in arr {\n    println!(\"{}\",v);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023230822-34j2dxz","Type":"NodeParagraph","Properties":{"id":"20251023230822-34j2dxz","updated":"20251024145736"},"Children":[{"Type":"NodeText","Data":"Rust 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。"}]},{"ID":"20251024145737-ohi0re3","Type":"NodeParagraph","Properties":{"id":"20251024145737-ohi0re3","updated":"20251024145849"},"Children":[{"Type":"NodeText","Data":"Rust 中数组是迭代器？不，数组实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IntoIterator"},{"Type":"NodeText","Data":"​ 特征，Rust 通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 语法糖，自动把实现了该特征的数组类型转换为迭代器，你也可以为自己的集合类型实现此特征），最终让我们可以直接对一个数组进行迭代"}]},{"ID":"20251024145902-x52w2p8","Type":"NodeParagraph","Properties":{"id":"20251024145902-x52w2p8","updated":"20251024145902"},"Children":[{"Type":"NodeText","Data":"直接对数值序列进行迭代，也是很常见的使用方式。"}]},{"ID":"20251024145903-85tjxh8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024145903-85tjxh8","updated":"20251024145908"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"for i in 1..10 {\n    println!(\"{}\", i);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024145801-0mcuw4f","Type":"NodeParagraph","Properties":{"id":"20251024145801-0mcuw4f","updated":"20251024145928"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IntoIterator"},{"Type":"NodeText","Data":"​ 特征拥有一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"into_iter"},{"Type":"NodeText","Data":"​ 方法，因此我们还可以显式的把数组转换成迭代器："}]},{"ID":"20251024145930-3a9n8ip","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024145930-3a9n8ip","updated":"20251024145934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let arr = [1, 2, 3];\nfor v in arr.into_iter() {\n    println!(\"{}\", v);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150003-jm4fcgw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024150003-jm4fcgw","updated":"20251024150044"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96","TextMarkTextContent":"惰性初始化"}]},{"ID":"20251024150004-7nfnj2b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024150004-7nfnj2b","updated":"20251024150044"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"在 Rust 中，迭代器是惰性的，意味着如果你不使用它，只声明:那么它将不会发生任何事：\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"{}\", val);\n}\n在 for 循环之前，我们只是简单的创建了一个迭代器 v1_iter，此时不会发生任何迭代行为，只有在 for 循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。\n这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150057-m8hrguz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024150057-m8hrguz","updated":"20251024230955"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#next-%E6%96%B9%E6%B3%95","TextMarkTextContent":"next 方法"},{"Type":"NodeText","Data":" ：会移走原数组的所有权"}]},{"ID":"20251024150058-yj4dwab","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024150058-yj4dwab","updated":"20251024230955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub trait Iterator {\n    type Item;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e;\n\n    // 省略其余有默认实现的方法\n}\n\nfn main() {\n    let arr = [1, 2, 3];\n    let mut arr_iter = arr.into_iter();\n\n    assert_eq!(arr_iter.next(), Some(1));\n    assert_eq!(arr_iter.next(), Some(2));\n    assert_eq!(arr_iter.next(), Some(3));\n    assert_eq!(arr_iter.next(), None);\n}\n\n\n    let result = match IntoIterator::into_iter(values) {  //模拟一个for循环\n\tlet result = match values.into_iter() {  //模拟一个for循环  返回一个空值\n        mut iter =\u003e loop {\n            match iter.next() {\n                Some(x) =\u003e { println!(\"{}\", x); },\n                None =\u003e break,\n            }\n        },\n    };\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150540-dahlghy","Type":"NodeList","ListData":{},"Properties":{"id":"20251024150540-dahlghy","updated":"20251024150540"},"Children":[{"ID":"20251024150540-prm3wtt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-prm3wtt","updated":"20251024150540"},"Children":[{"ID":"20251024150540-dy216uc","Type":"NodeParagraph","Properties":{"id":"20251024150540-dy216uc","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Option"},{"Type":"NodeText","Data":"​ 类型，当有值时返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(i32)"},{"Type":"NodeText","Data":"​，无值时返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"None"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024150540-issuxvk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-issuxvk","updated":"20251024150540"},"Children":[{"ID":"20251024150540-z1n9bj9","Type":"NodeParagraph","Properties":{"id":"20251024150540-z1n9bj9","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(1)"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(2)"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(3)"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024150540-443x3ow","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-443x3ow","updated":"20251024150540"},"Children":[{"ID":"20251024150540-epon1g5","Type":"NodeParagraph","Properties":{"id":"20251024150540-epon1g5","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"手动迭代必须将迭代器声明为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mut"},{"Type":"NodeText","Data":"​ 可变，因为调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 会改变迭代器其中的状态数据（当前遍历的位置等），而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 循环去迭代则无需标注 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mut"},{"Type":"NodeText","Data":"​，因为它会帮我们自动完成"}]}]}]},{"ID":"20251024150548-3x464u2","Type":"NodeParagraph","Properties":{"id":"20251024150548-3x464u2","updated":"20251024150548"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法对"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"迭代器的遍历是消耗性的"},{"Type":"NodeText","Data":"，每次消耗它一个元素，最终迭代器中将没有任何元素，只能返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"None"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20251024180132-5tj027o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024180132-5tj027o","updated":"20251024181242"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#intoiterator-%E7%89%B9%E5%BE%81","TextMarkTextContent":"IntoIterator 特征"}]},{"ID":"20251024180133-fi8geys","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024180133-fi8geys","updated":"20251024180259"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"由于 Vec 动态数组实现了 IntoIterator 特征，因此可以通过 into_iter 将其转换为迭代器\n如果本身就是一个迭代器,迭代器自身也实现了 IntoIterator\nfn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter().into_iter().into_iter() {  //Iterator 转 IntoIterator\n        println!(\"{}\",v)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024180306-daws8bg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024180306-daws8bg","updated":"20251024181242"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#into_iter-iter-iter_mut","TextMarkTextContent":"into_iter, iter, iter_mut"}]},{"ID":"20251024180318-p3owp6c","Type":"NodeList","ListData":{},"Properties":{"id":"20251024180318-p3owp6c","updated":"20251024180318"},"Children":[{"ID":"20251024180318-zxpfq7f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-zxpfq7f","updated":"20251024180318"},"Children":[{"ID":"20251024180318-bbea2ir","Type":"NodeParagraph","Properties":{"id":"20251024180318-bbea2ir","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"into_iter"},{"Type":"NodeText","Data":"​ 会夺走所有权"}]}]},{"ID":"20251024180318-tw399hr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-tw399hr","updated":"20251024180318"},"Children":[{"ID":"20251024180318-52x62cw","Type":"NodeParagraph","Properties":{"id":"20251024180318-52x62cw","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"iter"},{"Type":"NodeText","Data":"​ 是借用"}]}]},{"ID":"20251024180318-qch8a75","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-qch8a75","updated":"20251024180318"},"Children":[{"ID":"20251024180318-bf0wuvl","Type":"NodeParagraph","Properties":{"id":"20251024180318-bf0wuvl","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"iter_mut"},{"Type":"NodeText","Data":"​ 是可变借用"}]}]}]},{"ID":"20251024180319-3v0kbcb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024180319-3v0kbcb","updated":"20251024181229"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter() {\n        println!(\"{}\", v)\n    }\n\n    // 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走\n    // println!(\"{:?}\",values);\n\n    let values = vec![1, 2, 3];\n    let _values_iter = values.iter();\n\n    // 不会报错，因为 values_iter 只是借用了 values 中的元素\n    println!(\"{:?}\", values);\n\n    let mut values = vec![1, 2, 3];\n    // 对 values 中的元素进行可变借用\n    let mut values_iter_mut = values.iter_mut();\n\n    // 取出第一个元素，并修改为0\n    if let Some(v) = values_iter_mut.next() {\n        *v = 0;\n    }\n\n    // 输出[0, 2, 3]\n    println!(\"{:?}\", values);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024181241-m1y35le","Type":"NodeList","ListData":{},"Properties":{"id":"20251024181241-m1y35le","updated":"20251024181241"},"Children":[{"ID":"20251024181241-qaf26uh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024181241-qaf26uh","updated":"20251024181241"},"Children":[{"ID":"20251024181241-3xh0gpn","Type":"NodeParagraph","Properties":{"id":"20251024181241-3xh0gpn","updated":"20251024181241"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":".iter()"},{"Type":"NodeText","Data":"​ 方法实现的迭代器，调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(\u0026amp;T)"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024181241-6ddzez8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024181241-6ddzez8","updated":"20251024181241"},"Children":[{"ID":"20251024181241-k3vdmt2","Type":"NodeParagraph","Properties":{"id":"20251024181241-k3vdmt2","updated":"20251024181241"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":".iter_mut()"},{"Type":"NodeText","Data":"​ 方法实现的迭代器，调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(\u0026amp;mut T)"},{"Type":"NodeText","Data":"​，因此在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"if let Some(v) = values_iter_mut.next()"},{"Type":"NodeText","Data":"​ 中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v"},{"Type":"NodeText","Data":"​ 的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut i32"},{"Type":"NodeText","Data":"​，最终我们可以通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*v = 0"},{"Type":"NodeText","Data":"​ 的方式修改其值"}]}]}]},{"ID":"20251024181330-m503lxe","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024181330-m503lxe","updated":"20251024181827"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#iterator-%E5%92%8C-intoiterator-%E7%9A%84%E5%8C%BA%E5%88%AB","TextMarkTextContent":"Iterator 和 IntoIterator 的区别"}]},{"ID":"20251024181331-mizt468","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024181331-mizt468","updated":"20251024181827"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"IntoIterator - \"可以变成迭代器\"\nIterator - \"是迭代器\"\n\nIterator 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 next\nIntoIterator 强调的是某一个类型如果实现了该特征，它可以通过 into_iter，iter 等方法变成一个迭代器\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024181807-p99shmo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024181807-p99shmo","updated":"20251024205439"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8","TextMarkTextContent":"消费者与适配器"}]},{"ID":"20251024204850-7qxz1zx","Type":"NodeParagraph","Properties":{"id":"20251024204850-7qxz1zx","updated":"20251024204850"},"Children":[{"Type":"NodeText","Data":"消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖 next 方法来消费元素，因此这也是为什么迭代器要实现 Iterator 特征，而该特征必须要实现 next 方法的原因。"}]},{"ID":"20251024204758-6m7ld3i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024204758-6m7ld3i","updated":"20251024205439"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8","TextMarkTextContent":"消费者适配器"},{"Type":"NodeText","Data":" ==方法"}]},{"ID":"20251024204758-aorf5sr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024204758-aorf5sr","linewrap":"true","updated":"20251024204824"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"只要迭代器上的某个方法 A 在其内部调用了 next 方法，那么 A 就被称为消费性适配器：因为 next 方法会消耗掉迭代器上的元素，所以方法 A 的调用也会消耗掉迭代器上的元素\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024205439-298sf5s","Type":"NodeList","ListData":{},"Properties":{"id":"20251024205439-298sf5s","updated":"20251024205439"},"Children":[{"ID":"20251024205439-uarg4l0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205439-uarg4l0","updated":"20251024205439"},"Children":[{"ID":"20251024205439-pkajacu","Type":"NodeParagraph","Properties":{"id":"20251024205439-pkajacu","updated":"20251024205439"},"Children":[{"Type":"NodeText","Data":"是迭代器的方法"}]}]},{"ID":"20251024205439-eah2448","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205439-eah2448","updated":"20251024205439"},"Children":[{"ID":"20251024205439-dmjafb5","Type":"NodeParagraph","Properties":{"id":"20251024205439-dmjafb5","updated":"20251024205439"},"Children":[{"Type":"NodeText","Data":"消耗掉迭代器，返回最终值"}]}]},{"ID":"20251024205439-d65y4yd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205439-d65y4yd","updated":"20251024205439"},"Children":[{"ID":"20251024205439-npxmtx6","Type":"NodeParagraph","Properties":{"id":"20251024205439-npxmtx6","updated":"20251024205439"},"Children":[{"Type":"NodeText","Data":"例如：sum(), collect(), count(), fold()"}]}]}]},{"ID":"20251024205600-46bar1i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024205600-46bar1i","updated":"20251024210948"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8","TextMarkTextContent":"迭代器适配器"},{"Type":"NodeText","Data":" == 方法"}]},{"ID":"20251024205608-tx5006t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024205608-tx5006t","linewrap":"true","updated":"20251024205635"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"既然消费者适配器是消费掉迭代器，然后返回一个值。那么迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键：v.iter().map().filter()...。\n迭代器适配器是惰性的，意味着你需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024205641-upd3eif","Type":"NodeList","ListData":{},"Properties":{"id":"20251024205641-upd3eif","updated":"20251024205641"},"Children":[{"ID":"20251024205641-xm7d9lq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205641-xm7d9lq","updated":"20251024205641"},"Children":[{"ID":"20251024205641-yahfgmx","Type":"NodeParagraph","Properties":{"id":"20251024205641-yahfgmx","updated":"20251024205641"},"Children":[{"Type":"NodeText","Data":"也是迭代器的方法"}]}]},{"ID":"20251024205641-wscxyxd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205641-wscxyxd","updated":"20251024205641"},"Children":[{"ID":"20251024205641-m15ytn4","Type":"NodeParagraph","Properties":{"id":"20251024205641-m15ytn4","updated":"20251024205641"},"Children":[{"Type":"NodeText","Data":"返回新的迭代器（惰性求值）"}]}]},{"ID":"20251024205641-1u3vhgw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024205641-1u3vhgw","updated":"20251024205641"},"Children":[{"ID":"20251024205641-ti2wstt","Type":"NodeParagraph","Properties":{"id":"20251024205641-ti2wstt","updated":"20251024205641"},"Children":[{"Type":"NodeText","Data":"例如：map(), filter(), take()"}]}]}]},{"ID":"20251024211100-th5yjrq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024211100-th5yjrq","updated":"20251024220657"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#collect","TextMarkTextContent":"collect"}]},{"ID":"20251024211101-jr7j9ne","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024211101-jr7j9ne","updated":"20251024213536"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"collect 方法，该方法就是一个消费者适配器，使用它可以将一个迭代器中的元素收集到指定类型中。\n\nlet v1: Vec\u003ci32\u003e = vec![1, 2, 3];\n//collect() 只调用 next()，不同迭代器的 next() 实现不同，collect() 就像一个收银员：收银员的工作永远一样：\"下一个！下一个！下一个！\"（调用 next()）\nlet v2: Vec\u003c_\u003e = v1.iter().map(|x| x + 1).collect();    //map也是一个迭代器\n\nassert_eq!(v2, vec![2, 3, 4]);\n\nv2 标注了 Vec\u003c_\u003e 类型，就是为了告诉 collect：请把迭代器中的元素消费掉，然后把值收集成 Vec\u003c_\u003e 类型，至于为何使用 _，因为编译器会帮我们自动推导\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024213447-69iyp2x","Type":"NodeParagraph","Properties":{"id":"20251024213447-69iyp2x","updated":"20251024215032"},"Children":[{"Type":"NodeText","Data":"例子："}]},{"ID":"20251024215032-u7wsz1k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024215032-u7wsz1k","updated":"20251024215054"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let name = [\"john\", \"yohan\",\"bob\"];\n    let age = [20, 21, 22];\n    let location = [\"new york\", \"los angeles\", \"chicago\"];\n    let forks:Vec\u003c_\u003e = name.into_iter().zip(age).zip(location)  //zip会把当前元素和输入的压缩为（x,y);\n        .map(|((x,y),z)|(x,y,z)).collect();\n    println!(\"{:?}\", forks);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024220658-92p7m1x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024220658-92p7m1x","updated":"20251024220919"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E9%80%82%E9%85%8D%E5%99%A8%E5%8F%82%E6%95%B0","TextMarkTextContent":"闭包作为适配器参数"}]},{"ID":"20251024220659-ux97qxv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024220659-ux97qxv","updated":"20251024220919"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"之前的 map 方法中，我们使用闭包来作为迭代器适配器的参数，它最大的好处不仅在于可以就地实现迭代器中元素的处理，还在于可以捕获环境值\n\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec\u003cShoe\u003e, shoe_size: u32) -\u003e Vec\u003cShoe\u003e {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\nfilter：传入闭包，进行比较，相等留下，不等排除\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024220927-62hcjvm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024220927-62hcjvm","updated":"20251024230156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E5%AE%9E%E7%8E%B0-iterator-%E7%89%B9%E5%BE%81","TextMarkTextContent":"实现 Iterator 特征"}]},{"ID":"20251024220928-q436js3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024220928-q436js3","updated":"20251024223448"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Counter {\n    count: u32,\n}\n\nimpl Counter {\n    fn new() -\u003e Counter {\n        Counter { count: 0 }\n    }\n}\n\nimpl Iterator for Counter {  //这里给Counter\n    type Item = u32;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.count \u003c 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n每次调用 next 方法，都会让计数器的值加一，然后返回最新的计数值，一旦计数大于 5，就返回 None。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024223457-9z0zs4k","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024223457-9z0zs4k","updated":"20251024230156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E5%AE%9E%E7%8E%B0-iterator-%E7%89%B9%E5%BE%81%E7%9A%84%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95","TextMarkTextContent":"实现 Iterator 特征的其它方法"}]},{"ID":"20251024223458-9kw8xx9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024223458-9kw8xx9","updated":"20251024225551"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"基本上实现一个next就可以了，其它方法都具有默认实现，所以无需像 next 这样手动去实现，而且这些默认实现的方法其实都是基于 next 方法实现的\nlet sum: u32 = Counter::new()\n    .zip(Counter::new().skip(1))  skip是跳过n个元素开始，zip遇到None停止， 流程是外面的先给zip，里面的计算，skip跳过一个在给zip，循环到有None结束\n    .map(|(a, b)| a * b)\t//重写计算排序\n    .filter(|x| x % 3 == 0)   //排除\n    .sum();\t\t//取和\nassert_eq!(18, sum);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024225605-wce4ixk","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20251024225605-wce4ixk","updated":"20251024230156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#enumerate","TextMarkTextContent":"enumerate"}]},{"ID":"20251024225606-sdxg26y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024225606-sdxg26y","updated":"20251024230156"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"首先 v.iter() 创建迭代器，其次 调用 Iterator 特征上的方法 enumerate，该方法产生一个新的迭代器，其中每个元素均是元组 (索引，值)\nlet v = vec![1u64, 2, 3, 4, 5, 6];\nfor (i,v) in v.iter().enumerate() {\n    println!(\"第{}个值是{}\",i,v)\n}\n用处\nlet v = vec![1u64, 2, 3, 4, 5, 6];\nlet val = v.iter()\n    .enumerate()\n    // 每两个元素剔除一个\n    // [1, 3, 5]\n    .filter(|\u0026(idx, _)| idx % 2 == 0)\n    .map(|(_, val)| val)\n    // 累加 1+3+5 = 9\n    .fold(0u64, |sum, acm| sum + acm);  //折叠累计， sum给一个初始值0，然后acm是上一个传下来的，累加，然后sum=sum+acm，acm传下一个值，这里可以结构\n\t//结构就是  .fold(0u64, |sum, acm| sum + acm*2);  可以这样写，方法不限\nprintln!(\"{}\", val);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024230223-owuwfaj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024230223-owuwfaj","updated":"20251024230428"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD","TextMarkTextContent":"迭代器的性能"}]},{"ID":"20251024230224-ebpg0a3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024230224-ebpg0a3","linewrap":"true","updated":"20251024230357"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"for 循环和迭代器 iterator 完成同样的求和任务的性能对比，迭代器还要更快一点\n迭代器是 Rust 的 零成本抽象（zero-cost abstractions）之一，意味着抽象并不会引入运行时开销，这与 Bjarne Stroustrup（C++ 的设计和实现者）在 Foundations of C++（2012） 中所定义的 零开销（zero-overhead）如出一辙\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024230401-8wghkrv","Type":"NodeParagraph","Properties":{"id":"20251024230401-8wghkrv","updated":"20251024230427"},"Children":[{"Type":"NodeText","Data":"迭代器是 Rust 受函数式语言启发而提供的高级语言特性，可以写出更加简洁、逻辑清晰的代码。编译器还可以通过循环展开（Unrolling）、向量化、消除边界检查等优化手段，使得迭代器和 for 循环都有极为高效的执行效率"}]},{"ID":"20251024230428-h3otmy2","Type":"NodeParagraph","Properties":{"id":"20251024230428-h3otmy2","updated":"20251024230428"}}]}