{"ID":"20251022102742-i96qnmf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251022102742-i96qnmf","title":"迭代器 Iterator","type":"doc","updated":"20251024181827"},"Children":[{"ID":"20251023230819-62c7jvt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251023230819-62c7jvt","updated":"20251024145935"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#for-%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8","TextMarkTextContent":"For 循环与迭代器"}]},{"ID":"20251023230820-epj8adh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251023230820-epj8adh","updated":"20251024145709"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"迭代器跟 for 循环颇为相似，都是去遍历一个集合，但是实际上它们存在不小的差别，其中最主要的差别就是：是否通过索引来访问集合。\nlet arr = [1, 2, 3];\nfor (let i = 0; i \u003c arr.length; i++) {\n  console.log(arr[i]);\n}\nlet arr = [1, 2, 3];\nfor v in arr {\n    println!(\"{}\",v);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251023230822-34j2dxz","Type":"NodeParagraph","Properties":{"id":"20251023230822-34j2dxz","updated":"20251024145736"},"Children":[{"Type":"NodeText","Data":"Rust 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 循环是编译器提供的语法糖，最终还是对迭代器中的元素进行遍历。"}]},{"ID":"20251024145737-ohi0re3","Type":"NodeParagraph","Properties":{"id":"20251024145737-ohi0re3","updated":"20251024145849"},"Children":[{"Type":"NodeText","Data":"Rust 中数组是迭代器？不，数组实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IntoIterator"},{"Type":"NodeText","Data":"​ 特征，Rust 通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 语法糖，自动把实现了该特征的数组类型转换为迭代器，你也可以为自己的集合类型实现此特征），最终让我们可以直接对一个数组进行迭代"}]},{"ID":"20251024145902-x52w2p8","Type":"NodeParagraph","Properties":{"id":"20251024145902-x52w2p8","updated":"20251024145902"},"Children":[{"Type":"NodeText","Data":"直接对数值序列进行迭代，也是很常见的使用方式。"}]},{"ID":"20251024145903-85tjxh8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024145903-85tjxh8","updated":"20251024145908"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"for i in 1..10 {\n    println!(\"{}\", i);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024145801-0mcuw4f","Type":"NodeParagraph","Properties":{"id":"20251024145801-0mcuw4f","updated":"20251024145928"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"IntoIterator"},{"Type":"NodeText","Data":"​ 特征拥有一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"into_iter"},{"Type":"NodeText","Data":"​ 方法，因此我们还可以显式的把数组转换成迭代器："}]},{"ID":"20251024145930-3a9n8ip","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024145930-3a9n8ip","updated":"20251024145934"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let arr = [1, 2, 3];\nfor v in arr.into_iter() {\n    println!(\"{}\", v);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150003-jm4fcgw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024150003-jm4fcgw","updated":"20251024150044"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96","TextMarkTextContent":"惰性初始化"}]},{"ID":"20251024150004-7nfnj2b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024150004-7nfnj2b","updated":"20251024150044"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"在 Rust 中，迭代器是惰性的，意味着如果你不使用它，只声明:那么它将不会发生任何事：\nlet v1 = vec![1, 2, 3];\n\nlet v1_iter = v1.iter();\n\nfor val in v1_iter {\n    println!(\"{}\", val);\n}\n在 for 循环之前，我们只是简单的创建了一个迭代器 v1_iter，此时不会发生任何迭代行为，只有在 for 循环开始后，迭代器才会开始迭代其中的元素，最后打印出来。\n这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150057-m8hrguz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024150057-m8hrguz","updated":"20251024180058"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#next-%E6%96%B9%E6%B3%95","TextMarkTextContent":"next 方法"}]},{"ID":"20251024150058-yj4dwab","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024150058-yj4dwab","updated":"20251024180058"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"pub trait Iterator {\n    type Item;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e;\n\n    // 省略其余有默认实现的方法\n}\n\nfn main() {\n    let arr = [1, 2, 3];\n    let mut arr_iter = arr.into_iter();\n\n    assert_eq!(arr_iter.next(), Some(1));\n    assert_eq!(arr_iter.next(), Some(2));\n    assert_eq!(arr_iter.next(), Some(3));\n    assert_eq!(arr_iter.next(), None);\n}\n\n\n    let result = match IntoIterator::into_iter(values) {  //模拟一个for循环\n\tlet result = match values.into_iter {  //模拟一个for循环\n        mut iter =\u003e loop {\n            match iter.next() {\n                Some(x) =\u003e { println!(\"{}\", x); },\n                None =\u003e break,\n            }\n        },\n    };\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024150540-dahlghy","Type":"NodeList","ListData":{},"Properties":{"id":"20251024150540-dahlghy","updated":"20251024150540"},"Children":[{"ID":"20251024150540-prm3wtt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-prm3wtt","updated":"20251024150540"},"Children":[{"ID":"20251024150540-dy216uc","Type":"NodeParagraph","Properties":{"id":"20251024150540-dy216uc","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Option"},{"Type":"NodeText","Data":"​ 类型，当有值时返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(i32)"},{"Type":"NodeText","Data":"​，无值时返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"None"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024150540-issuxvk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-issuxvk","updated":"20251024150540"},"Children":[{"ID":"20251024150540-z1n9bj9","Type":"NodeParagraph","Properties":{"id":"20251024150540-z1n9bj9","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"遍历是按照迭代器中元素的排列顺序依次进行的，因此我们严格按照数组中元素的顺序取出了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(1)"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(2)"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(3)"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024150540-443x3ow","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024150540-443x3ow","updated":"20251024150540"},"Children":[{"ID":"20251024150540-epon1g5","Type":"NodeParagraph","Properties":{"id":"20251024150540-epon1g5","updated":"20251024150540"},"Children":[{"Type":"NodeText","Data":"手动迭代必须将迭代器声明为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mut"},{"Type":"NodeText","Data":"​ 可变，因为调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 会改变迭代器其中的状态数据（当前遍历的位置等），而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​ 循环去迭代则无需标注 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mut"},{"Type":"NodeText","Data":"​，因为它会帮我们自动完成"}]}]}]},{"ID":"20251024150548-3x464u2","Type":"NodeParagraph","Properties":{"id":"20251024150548-3x464u2","updated":"20251024150548"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法对"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"迭代器的遍历是消耗性的"},{"Type":"NodeText","Data":"，每次消耗它一个元素，最终迭代器中将没有任何元素，只能返回 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"None"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20251024180132-5tj027o","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024180132-5tj027o","updated":"20251024181242"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#intoiterator-%E7%89%B9%E5%BE%81","TextMarkTextContent":"IntoIterator 特征"}]},{"ID":"20251024180133-fi8geys","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024180133-fi8geys","updated":"20251024180259"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"由于 Vec 动态数组实现了 IntoIterator 特征，因此可以通过 into_iter 将其转换为迭代器\n如果本身就是一个迭代器,迭代器自身也实现了 IntoIterator\nfn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter().into_iter().into_iter() {  //Iterator 转 IntoIterator\n        println!(\"{}\",v)\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024180306-daws8bg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024180306-daws8bg","updated":"20251024181242"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#into_iter-iter-iter_mut","TextMarkTextContent":"into_iter, iter, iter_mut"}]},{"ID":"20251024180318-p3owp6c","Type":"NodeList","ListData":{},"Properties":{"id":"20251024180318-p3owp6c","updated":"20251024180318"},"Children":[{"ID":"20251024180318-zxpfq7f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-zxpfq7f","updated":"20251024180318"},"Children":[{"ID":"20251024180318-bbea2ir","Type":"NodeParagraph","Properties":{"id":"20251024180318-bbea2ir","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"into_iter"},{"Type":"NodeText","Data":"​ 会夺走所有权"}]}]},{"ID":"20251024180318-tw399hr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-tw399hr","updated":"20251024180318"},"Children":[{"ID":"20251024180318-52x62cw","Type":"NodeParagraph","Properties":{"id":"20251024180318-52x62cw","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"iter"},{"Type":"NodeText","Data":"​ 是借用"}]}]},{"ID":"20251024180318-qch8a75","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024180318-qch8a75","updated":"20251024180318"},"Children":[{"ID":"20251024180318-bf0wuvl","Type":"NodeParagraph","Properties":{"id":"20251024180318-bf0wuvl","updated":"20251024180318"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"iter_mut"},{"Type":"NodeText","Data":"​ 是可变借用"}]}]}]},{"ID":"20251024180319-3v0kbcb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024180319-3v0kbcb","updated":"20251024181229"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let values = vec![1, 2, 3];\n\n    for v in values.into_iter() {\n        println!(\"{}\", v)\n    }\n\n    // 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走\n    // println!(\"{:?}\",values);\n\n    let values = vec![1, 2, 3];\n    let _values_iter = values.iter();\n\n    // 不会报错，因为 values_iter 只是借用了 values 中的元素\n    println!(\"{:?}\", values);\n\n    let mut values = vec![1, 2, 3];\n    // 对 values 中的元素进行可变借用\n    let mut values_iter_mut = values.iter_mut();\n\n    // 取出第一个元素，并修改为0\n    if let Some(v) = values_iter_mut.next() {\n        *v = 0;\n    }\n\n    // 输出[0, 2, 3]\n    println!(\"{:?}\", values);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024181241-m1y35le","Type":"NodeList","ListData":{},"Properties":{"id":"20251024181241-m1y35le","updated":"20251024181241"},"Children":[{"ID":"20251024181241-qaf26uh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024181241-qaf26uh","updated":"20251024181241"},"Children":[{"ID":"20251024181241-3xh0gpn","Type":"NodeParagraph","Properties":{"id":"20251024181241-3xh0gpn","updated":"20251024181241"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":".iter()"},{"Type":"NodeText","Data":"​ 方法实现的迭代器，调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(\u0026amp;T)"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251024181241-6ddzez8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251024181241-6ddzez8","updated":"20251024181241"},"Children":[{"ID":"20251024181241-k3vdmt2","Type":"NodeParagraph","Properties":{"id":"20251024181241-k3vdmt2","updated":"20251024181241"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":".iter_mut()"},{"Type":"NodeText","Data":"​ 方法实现的迭代器，调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"next"},{"Type":"NodeText","Data":"​ 方法返回的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Some(\u0026amp;mut T)"},{"Type":"NodeText","Data":"​，因此在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"if let Some(v) = values_iter_mut.next()"},{"Type":"NodeText","Data":"​ 中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"v"},{"Type":"NodeText","Data":"​ 的类型是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut i32"},{"Type":"NodeText","Data":"​，最终我们可以通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*v = 0"},{"Type":"NodeText","Data":"​ 的方式修改其值"}]}]}]},{"ID":"20251024181330-m503lxe","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251024181330-m503lxe","updated":"20251024181827"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#iterator-%E5%92%8C-intoiterator-%E7%9A%84%E5%8C%BA%E5%88%AB","TextMarkTextContent":"Iterator 和 IntoIterator 的区别"}]},{"ID":"20251024181331-mizt468","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251024181331-mizt468","updated":"20251024181827"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"IntoIterator - \"可以变成迭代器\"\nIterator - \"是迭代器\"\n\nIterator 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 next\nIntoIterator 强调的是某一个类型如果实现了该特征，它可以通过 into_iter，iter 等方法变成一个迭代器\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251024181807-p99shmo","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251024181807-p99shmo","updated":"20251024181824"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/functional-programing/iterator.html#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8","TextMarkTextContent":"消费者与适配器"}]},{"ID":"20251024181824-vsub52z","Type":"NodeParagraph","Properties":{"id":"20251024181824-vsub52z","updated":"20251024181824"}}]}