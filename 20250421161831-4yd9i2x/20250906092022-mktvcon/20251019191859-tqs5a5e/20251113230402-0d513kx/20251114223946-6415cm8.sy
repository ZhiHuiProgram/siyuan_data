{"ID":"20251114223946-6415cm8","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251114223946-6415cm8","title":"使用多线程","type":"doc","updated":"20251117212357"},"Children":[{"ID":"20251114223950-y9mk787","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251114223950-y9mk787","updated":"20251114224424"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B","TextMarkTextContent":"创建线程"},{"Type":"NodeText","Data":" ：闭包或者函数"}]},{"ID":"20251114223951-qwscsf9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251114223951-qwscsf9","updated":"20251114224424"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..5 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();  //join线程，线程可能返回东西\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nfn my_func() -\u003e i32{\n    for tt in 1..10  {\n        println!(\"this is {}\",tt);\n        thread::sleep(Duration::from_millis(100));\n    }\n    32\n}\n\nfn main(){\n    let ret= thread::spawn(my_func);\n    ret.join();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251114224823-allqehx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251114224823-allqehx","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8-move","TextMarkTextContent":"在线程闭包中使用 move"}]},{"ID":"20251114224824-g6dc7hd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251114224824-g6dc7hd","updated":"20251114225149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];  \n\n    let handle = thread::spawn(move || {  //这里加了move\n        println!(\"Here's a vector: {:?}\", v); //闭包无法确定捕获的v会活多久\n    });\n\n\t//如果 drop(v);\n    handle.join().unwrap();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-2jmdofe","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-2jmdofe","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B","TextMarkTextContent":"创建线程"},{"Type":"NodeText","Data":" ：闭包或者函数"}]},{"ID":"20251117212349-x5doybp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-x5doybp","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..5 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();  //join线程，线程可能返回东西\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nfn my_func() -\u003e i32{\n    for tt in 1..10  {\n        println!(\"this is {}\",tt);\n        thread::sleep(Duration::from_millis(100));\n    }\n    32\n}\n\nfn main(){\n    let ret= thread::spawn(my_func);\n    ret.join();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-pvekig2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-pvekig2","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8-move","TextMarkTextContent":"在线程闭包中使用 move"}]},{"ID":"20251117212349-mxev7ca","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-mxev7ca","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];  \n\n    let handle = thread::spawn(move || {  //这里加了move\n        println!(\"Here's a vector: {:?}\", v); //闭包无法确定捕获的v会活多久\n    });\n\n\t//如果 drop(v);\n    handle.join().unwrap();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-unnqwmu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-unnqwmu","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E7%BA%BF%E7%A8%8B%E5%B1%8F%E9%9A%9Cbarrier","TextMarkTextContent":"线程屏障(Barrier)"}]},{"ID":"20251117212349-nbj3ysc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-nbj3ysc","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::{Arc, Barrier};\nuse std::thread;\n\nfn main() {\n    let mut handles = Vec::with_capacity(6);\n    let barrier = Arc::new(Barrier::new(6));  //创建了6个线程屏障,\n\n    for _ in 0..6 {\n        let b = barrier.clone();\n        handles.push(thread::spawn(move|| {\n            println!(\"before wait\");\n\t\t\t//这里有屏障的引用计数，如果线程大于屏障，只会屏蔽住六个，多余的重新计数，不足六个就会卡住\n\t\t\t//如果线程小于屏障，会卡死，直到计数大于6\n            b.wait();\n            println!(\"after wait\");\n        }));\n    }\n\n    for handle in handles {  //会自动调用into_iter()，并且join会拿走所有权，不能用不可变方法\n        handle.join().unwrap();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-o4n3jvf","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-o4n3jvf","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8Fthread-local-variable","TextMarkTextContent":"线程局部变量(Thread Local Variable)"}]},{"ID":"20251117212349-9girvy6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251117212349-9girvy6","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E6%A0%87%E5%87%86%E5%BA%93-thread_local","TextMarkTextContent":"标准库 thread_local"}]},{"ID":"20251117212349-2ufa2kq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251117212349-2ufa2kq","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"thread_local!"},{"Type":"NodeText","Data":"​ 的优势：线程内全局访问"}]},{"ID":"20251117212349-tkmatl0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-tkmatl0","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cnVzdA=="},{"Type":"NodeCodeBlockCode","Data":"thread_local!(static X: RefCell\u003cu32\u003e = RefCell::new(1));\n\nfn main() {\n    thread::spawn(|| {\n        X.with(|x| *x.borrow_mut() = 2); // 线程内修改\n        foo(); // 调用函数\n    }).join().unwrap();\n}\n\nfn foo() {\n    X.with(|x| println!(\"x: {}\", x.borrow())); // 线程内任何函数都能访问\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-9g956gd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-9g956gd","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::cell::RefCell;\nuse std::thread;\n\nfn main() {\n    thread_local!(static FOO: RefCell\u003cu32\u003e = RefCell::new(1));  //这个宏试了一下，放在哪里都有效，static开局就展开了\n\n    FOO.with(|f| {\n        assert_eq!(*f.borrow(), 1);\n        *f.borrow_mut() = 2;\n    });\n    // 每个线程开始时都会拿到线程局部变量的FOO的初始值\n    let t = thread::spawn(move || {\n        FOO.with(|f| {\n            assert_eq!(*f.borrow(), 1);\n            *f.borrow_mut() = 3;\n        });\n    });\n\n    // 等待线程完成\n    t.join().unwrap();\n    // 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2\n    FOO.with(|f| {\n        assert_eq!(*f.borrow(), 2);\n    });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-l53j3qf","Type":"NodeParagraph","Properties":{"id":"20251117212349-l53j3qf","updated":"20251117212349"},"Children":[{"Type":"NodeText","Data":"你还可以在结构体中使用线程局部变量："}]},{"ID":"20251117212349-hodsd8c","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-hodsd8c","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct Foo;\nimpl Foo {\n    thread_local! {\n        static FOO: RefCell\u003cusize\u003e = RefCell::new(0);\n    }\n}\n\nfn main() {\n    Foo::FOO.with(|x| println!(\"{:?}\", x));\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-nqbv0cr","Type":"NodeParagraph","Properties":{"id":"20251117212349-nqbv0cr","updated":"20251117212349"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LocalKey"},{"Type":"NodeText","Data":"​ 与 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"thread_local!"},{"Type":"NodeText","Data":"​ 宏是"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"紧密绑定、不可分割"},{"Type":"NodeText","Data":"的关系："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LocalKey"},{"Type":"NodeText","Data":"​ 是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"thread_local!"},{"Type":"NodeText","Data":"​ 宏生成的线程局部变量的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实际类型"},{"Type":"NodeText","Data":"，而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"thread_local!"},{"Type":"NodeText","Data":"​ 宏是创建 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"LocalKey"},{"Type":"NodeText","Data":"​ 实例的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"唯一方式"},{"Type":"NodeText","Data":"。"}]},{"ID":"20251117212349-5xede2e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-5xede2e","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::cell::RefCell;\nuse std::thread::LocalKey;\n\nthread_local! {\n    static FOO: RefCell\u003cusize\u003e = RefCell::new(0);\n}\nstruct Bar {\n    foo: \u0026'static LocalKey\u003cRefCell\u003cusize\u003e\u003e,  //结构体引用\n}\nimpl Bar {\n    fn constructor() -\u003e Self {\n        Self {\n            foo: \u0026FOO,\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-p5tzpe5","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251117212349-p5tzpe5","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E4%B8%89%E6%96%B9%E5%BA%93-thread-local","TextMarkTextContent":"三方库 thread-local"}]},{"ID":"20251117212349-2gckxjg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-2gckxjg","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"ThreadLocal 允许主线程在所有子线程结束后，收集所有线程的局部变量副本\n\n可以统计局部变量被多少个线程用过\n\n当线程退出后，其线程 ID 可能被操作系统分配给新创建的线程，而 ThreadLocal 内部可能会将 “已退出线程的局部变量副本” 重新分配给复用了该 ID 的新线程，导致最终收集到的副本数量少于初始线程数。\n\n因为ID可能出现复用的情况，所以复用ID的新线程会拿到原来ID的线程使用的ThreadLocal副本，在副本个数上加一\n线程 1 启动 → 创建副本 A（计数 0）→ 加 1 → 退出（副本 A 保留，ID1 被回收）。\n线程 2 启动 → 创建副本 B（计数 0）→ 加 1 → 退出。\n线程 3 启动 → 创建副本 C（计数 0）→ 加 1 → 退出。\n线程 4 启动 → 创建副本 D（计数 0）→ 加 1 → 退出。\n线程 5 启动 → 复用 ID1 → 发现副本 A → 加 1（副本 A 的计数从 1 变成 2）→ 退出。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-fjls462","Type":"NodeParagraph","Properties":{"id":"20251117212349-fjls462","updated":"20251117212349"},"Children":[{"Type":"NodeText","Data":"代码"}]},{"ID":"20251117212349-3dx89w7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-3dx89w7","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use thread_local::ThreadLocal;\nuse std::sync::Arc;\nuse std::cell::Cell;\nuse std::thread;\n\nlet tls = Arc::new(ThreadLocal::new()); //这里可能有bug，要修一下，目前修好了但是看不懂为什么\nlet mut v = vec![];\n// 创建多个线程\nfor _ in 0..5 {\n    let tls2 = tls.clone();\n    let handle = thread::spawn(move || {\n        // 将计数器加1\n        // 请注意，由于线程 ID 在线程退出时会被回收，因此一个线程有可能回收另一个线程的对象\n        // 这只能在线程退出后发生，因此不会导致任何竞争条件\n        let cell = tls2.get_or(|| Cell::new(0));  //这里可能有bug\n        cell.set(cell.get() + 1);\n    });\n    v.push(handle);\n}\nfor handle in v {\n    handle.join().unwrap();\n}\n// 一旦所有子线程结束，收集它们的线程局部变量中的计数器值，然后进行求和\nlet tls = Arc::try_unwrap(tls).unwrap();\nlet total = tls.into_iter().fold(0, |x, y| {\n    // 打印每个线程局部变量中的计数器值，发现不一定有5个线程，\n    // 因为一些线程已退出，并且其他线程会回收退出线程的对象\n    println!(\"x: {}, y: {}\", x, y.get());\n    x + y.get()\n});\n\n// 和为5\nassert_eq!(total, 5);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-upuexcy","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-upuexcy","updated":"20251117212349"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E6%89%A7%E8%A1%8C","TextMarkTextContent":"用条件控制线程的挂起和执行"}]},{"ID":"20251117212349-rs6bjrf","Type":"NodeParagraph","Properties":{"id":"20251117212349-rs6bjrf","updated":"20251117212349"},"Children":[{"Type":"NodeText","Data":"条件变量(Condition Variables)经常和 Mutex 一起使用，可以让线程挂起，直到某个条件发生后再继续执行"}]},{"ID":"20251117212349-ay2eol4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-ay2eol4","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread;\nuse std::sync::{Arc, Mutex, Condvar};\n\nfn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = pair.clone();\n\n    thread::spawn(move|| {\n        let (lock, cvar) = \u0026*pair2;\n        let mut started = lock.lock().unwrap();\n        println!(\"changing started\");\n        *started = true;\n        cvar.notify_one();\n    });\n\n    let (lock, cvar) = \u0026*pair;\n    let mut started = lock.lock().unwrap();  //started 是 锁， *started是锁的标记， 不影响拿锁释放锁，线程交互信号用\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n\n    println!(\"started changed\");\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212349-lw9pnee","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117212349-lw9pnee","updated":"20251117212357"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/thread.html#%E5%8F%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E7%9A%84%E5%87%BD%E6%95%B0","TextMarkTextContent":"只被调用一次的函数"}]},{"ID":"20251117212349-pkjp7vd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117212349-pkjp7vd","updated":"20251117212349"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::thread; \nuse std::sync::Once;  //Once类型\nuse std::time::Duration;\nstatic mut VAL: usize = 0;\nstatic INIT: Once = Once::new();\n\nfn main() {\n    let handle1 = thread::spawn(move || {\n        thread::sleep(Duration::from_millis(30));  //这里有个延时\n        INIT.call_once(|| {\n            unsafe {\n                VAL += 1;\n            }\n        });\n    });\n\n    let handle2 = thread::spawn(move || {  //这个线程会先跑\n        INIT.call_once(|| {\n            unsafe {\n                VAL += 2;\n            }\n        });\n    });\n\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n\n    println!(\"{}\", unsafe { VAL });  //结果等于2，线程1的INIT没有执行闭包\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117212357-j19ug8d","Type":"NodeParagraph","Properties":{"id":"20251117212357-j19ug8d","updated":"20251117212357"}}]}