{"ID":"20251117215643-5nge4at","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251117215643-5nge4at","title":"线程间的消息传递","type":"doc","updated":"20251118213546"},"Children":[{"ID":"20251117215643-yu5uiut","Type":"NodeParagraph","Properties":{"id":"20251117215643-yu5uiut","updated":"20251117220514"},"Children":[{"Type":"NodeText","Data":"在多线程间有多种方式可以共享、传递数据，最常用的方式就是通过消息传递或者将锁和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc"},{"Type":"NodeText","Data":"​联合使用，而对于前者，在编程界还有一个大名鼎鼎的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Actor线程模型"},{"Type":"NodeText","Data":"​为其背书，典型的有 Erlang 语言，还有 Go 语言中很经典的一句话："}]},{"ID":"20251117220521-f89lw6x","Type":"NodeParagraph","Properties":{"id":"20251117220521-f89lw6x","updated":"20251117220557"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Do not communicate by sharing memory; instead, share memory by communicating"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251117220604-hhw3l7u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117220604-hhw3l7u","updated":"20251117220621"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93","TextMarkTextContent":"消息通道"}]},{"ID":"20251117220620-1f69lg7","Type":"NodeParagraph","Properties":{"id":"20251117220620-1f69lg7","updated":"20251117220621"},"Children":[{"Type":"NodeText","Data":"Rust 是在标准库里提供了消息通道("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channel"},{"Type":"NodeText","Data":"​)，你可以将其想象成一场直播，多个主播联合起来在搞一场直播，最终内容通过通道传输给屏幕前的我们，其中主播被称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"发送者"},{"Type":"NodeText","Data":"，观众被称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"接收者"},{"Type":"NodeText","Data":"，显而易见的是：一个通道应该支持多个发送者和接收者。"}]},{"ID":"20251117220625-6iuzz4j","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117220625-6iuzz4j","updated":"20251117221654"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85%E5%8D%95%E6%8E%A5%E6%94%B6%E8%80%85","TextMarkTextContent":"多发送者，单接收者"}]},{"ID":"20251117220626-7eeyb9f","Type":"NodeParagraph","Properties":{"id":"20251117220626-7eeyb9f","updated":"20251117221100"},"Children":[{"Type":"NodeText","Data":"标准库提供了通道"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::sync::mpsc"},{"Type":"NodeText","Data":"​,其中"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mpsc"},{"Type":"NodeText","Data":"​是"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"multiple producer, single consumer"},{"Type":"NodeText","Data":"的缩写"}]},{"ID":"20251117221100-s19b59j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117221100-s19b59j","updated":"20251117221531"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    // 创建一个消息通道, 返回一个元组：(发送者，接收者)\n    let (tx, rx) = mpsc::channel();\n\n    // 创建线程，并发送消息\n    for i in 1..3 {\n        let tx1 = tx.clone();\n        thread::spawn(move || {\n            // 发送一个数字1, send方法返回Result\u003cT,E\u003e，通过unwrap进行快速错误处理\n            tx1.send(i).unwrap();\n\n            // 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option\u003ci32\u003e类型将产生不匹配错误\n            // tx.send(Some(1)).unwrap()\n        });\n    }\n    // 在主线程中接收子线程发送的消息并输出\n    println!(\"receive {}\", rx.recv().unwrap());\n    println!(\"receive {}\", rx.recv().unwrap());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117221546-7469aga","Type":"NodeList","ListData":{},"Properties":{"id":"20251117221546-7469aga","updated":"20251117221546"},"Children":[{"ID":"20251117221546-ygnpo8h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117221546-ygnpo8h","updated":"20251117221546"},"Children":[{"ID":"20251117221546-omoc4jc","Type":"NodeParagraph","Properties":{"id":"20251117221546-omoc4jc","updated":"20251117221546"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tx"},{"Type":"NodeText","Data":"​,"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rx"},{"Type":"NodeText","Data":"​对应发送者和接收者，它们的类型由编译器自动推导: "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tx.send(1)"},{"Type":"NodeText","Data":"​发送了整数，因此它们分别是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mpsc::Sender\u0026lt;i32\u0026gt;"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mpsc::Receiver\u0026lt;i32\u0026gt;"},{"Type":"NodeText","Data":"​类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"i32"},{"Type":"NodeText","Data":"​类型的值将导致编译错误"}]}]},{"ID":"20251117221546-myrtd6u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117221546-myrtd6u","updated":"20251117221546"},"Children":[{"ID":"20251117221546-c770xyc","Type":"NodeParagraph","Properties":{"id":"20251117221546-c770xyc","updated":"20251117221546"},"Children":[{"Type":"NodeText","Data":"接收消息的操作"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rx.recv()"},{"Type":"NodeText","Data":"​会阻塞当前线程，直到读取到值，或者通道被关闭"}]}]},{"ID":"20251117221546-xrm8uax","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117221546-xrm8uax","updated":"20251117221546"},"Children":[{"ID":"20251117221546-rn3chvp","Type":"NodeParagraph","Properties":{"id":"20251117221546-rn3chvp","updated":"20251117221546"},"Children":[{"Type":"NodeText","Data":"需要使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"move"},{"Type":"NodeText","Data":"​将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tx"},{"Type":"NodeText","Data":"​的所有权转移到子线程的闭包中"}]}]}]},{"ID":"20251117221547-zimdpcc","Type":"NodeParagraph","Properties":{"id":"20251117221547-zimdpcc","updated":"20251117221654"},"Children":[{"Type":"NodeText","Data":"在注释中提到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"send"},{"Type":"NodeText","Data":"​方法返回一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Result\u0026lt;T,E\u0026gt;"},{"Type":"NodeText","Data":"​，说明它有可能返回一个错误，例如接收者被"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"drop"},{"Type":"NodeText","Data":"​导致了发送的值不会被任何人接收，此时继续发送毫无意义，因此返回一个错误最为合适，在代码中我们仅仅使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"unwrap"},{"Type":"NodeText","Data":"​进行了快速处理，但在实际项目中你需要对错误进行进一步的处理。"}]},{"ID":"20251117221658-8kkzn5k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117221658-8kkzn5k","updated":"20251117222547"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%9A%84-try_recv-%E6%96%B9%E6%B3%95","TextMarkTextContent":"不阻塞的 try_recv 方法"}]},{"ID":"20251117221659-byhqpt9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117221659-byhqpt9","updated":"20251117222547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(1).unwrap();\n    });\n\n    println!(\"receive {:?}\", rx.try_recv());\n    println!(\"receive {:?}\", rx.try_recv());\n    println!(\"receive {:?}\", rx.try_recv());\n}\n//打印了三个东西\nreceive Err(Empty)\nreceive Ok(1)\nreceive Err(Disconnected)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117222638-qkui4zh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117222638-qkui4zh","updated":"20251117222659"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BC%A0%E8%BE%93%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E6%95%B0%E6%8D%AE","TextMarkTextContent":"传输具有所有权的数据"}]},{"ID":"20251117222646-az50ryd","Type":"NodeList","ListData":{},"Properties":{"id":"20251117222646-az50ryd","updated":"20251117222646"},"Children":[{"ID":"20251117222646-gytfode","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117222646-gytfode","updated":"20251117222646"},"Children":[{"ID":"20251117222646-mkavxus","Type":"NodeParagraph","Properties":{"id":"20251117222646-mkavxus","updated":"20251117222646"},"Children":[{"Type":"NodeText","Data":"若值的类型实现了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Copy"},{"Type":"NodeText","Data":"​特征，则直接复制一份该值，然后传输过去，例如之前的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"i32"},{"Type":"NodeText","Data":"​类型"}]}]},{"ID":"20251117222646-boqo3wm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117222646-boqo3wm","updated":"20251117222646"},"Children":[{"ID":"20251117222646-or1hx8d","Type":"NodeParagraph","Properties":{"id":"20251117222646-or1hx8d","updated":"20251117222646"},"Children":[{"Type":"NodeText","Data":"若值没有实现"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Copy"},{"Type":"NodeText","Data":"​，则它的所有权会被转移给接收端，在发送端继续使用该值将报错"}]}]}]},{"ID":"20251117222639-qnprx2r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117222639-qnprx2r","updated":"20251117222658"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let s = String::from(\"我，飞走咯!\");\n        tx.send(s).unwrap();\n        println!(\"val is {}\", s);  //报错，没有所有权了\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117222857-v1am2r2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117222857-v1am2r2","updated":"20251117230206"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BD%BF%E7%94%A8-for-%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A5%E6%94%B6","TextMarkTextContent":"使用 for 进行循环接收"}]},{"ID":"20251117223134-txs2eo9","Type":"NodeParagraph","Properties":{"id":"20251117223134-txs2eo9","updated":"20251117223138"},"Children":[{"Type":"NodeText","Data":"迭代器，不好说什么"}]},{"ID":"20251117222858-q1vrjpi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117222858-q1vrjpi","updated":"20251117230206"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {  //rx可以用迭代器for循环，发送者都销毁了，退出循环\n        println!(\"Got: {}\", received);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117223225-kyhqxaw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251117223225-kyhqxaw","updated":"20251117223251"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85","TextMarkTextContent":"使用多发送者"}]},{"ID":"20251117223227-orj5jd9","Type":"NodeParagraph","Properties":{"id":"20251117223227-orj5jd9","updated":"20251117223231"},"Children":[{"Type":"NodeText","Data":"上面有，不写了"}]},{"ID":"20251117223250-pztc7zu","Type":"NodeList","ListData":{},"Properties":{"id":"20251117223250-pztc7zu","updated":"20251117223250"},"Children":[{"ID":"20251117223250-wnef16w","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117223250-wnef16w","updated":"20251117223250"},"Children":[{"ID":"20251117223250-psqorre","Type":"NodeParagraph","Properties":{"id":"20251117223250-psqorre","updated":"20251117223250"},"Children":[{"Type":"NodeText","Data":"需要所有的发送者都被"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"drop"},{"Type":"NodeText","Data":"​掉后，接收者"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"rx"},{"Type":"NodeText","Data":"​才会收到错误，进而跳出"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"for"},{"Type":"NodeText","Data":"​循环，最终结束主线程"}]}]},{"ID":"20251117223250-oex8aym","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117223250-oex8aym","updated":"20251117223250"},"Children":[{"ID":"20251117223250-d3nd4g6","Type":"NodeParagraph","Properties":{"id":"20251117223250-d3nd4g6","updated":"20251117223250"},"Children":[{"Type":"NodeText","Data":"这里虽然用了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clone"},{"Type":"NodeText","Data":"​但是并不会影响性能，因为它并不在热点代码路径中，仅仅会被执行一次"}]}]},{"ID":"20251117223250-k5s9n0q","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117223250-k5s9n0q","updated":"20251117223250"},"Children":[{"ID":"20251117223250-uqdyg70","Type":"NodeParagraph","Properties":{"id":"20251117223250-uqdyg70","updated":"20251117223250"},"Children":[{"Type":"NodeText","Data":"由于两个子线程谁先创建完成是未知的，因此哪条消息先发送也是未知的，最终主线程的输出顺序也不确定"}]}]}]},{"ID":"20251117223308-n7x6xdj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251117223308-n7x6xdj","updated":"20251117230359"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93","TextMarkTextContent":"同步和异步通道"}]},{"ID":"20251117225618-bouwr1o","Type":"NodeParagraph","Properties":{"id":"20251117225618-bouwr1o","updated":"20251117225619"},"Children":[{"Type":"NodeText","Data":"Rust 标准库的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mpsc"},{"Type":"NodeText","Data":"​通道其实分为两种类型：同步和异步"}]},{"ID":"20251117225624-6416s1d","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251117225624-6416s1d","updated":"20251117230359"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93","TextMarkTextContent":"异步通道"}]},{"ID":"20251117230341-bui0fku","Type":"NodeParagraph","Properties":{"id":"20251117230341-bui0fku","updated":"20251117230341"},"Children":[{"Type":"NodeText","Data":"之前我们使用的都是异步通道：无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:"}]},{"ID":"20251117223309-oj7yshl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117223309-oj7yshl","updated":"20251117230343"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nfn main() {\n    let (tx, rx)= mpsc::channel();\n\n    let handle = thread::spawn(move || {\n        println!(\"发送之前\");\n        tx.send(1).unwrap();\n        println!(\"发送之后\");\n    });\n\n    println!(\"睡眠之前\");\n    thread::sleep(Duration::from_secs(3));\n    println!(\"睡眠之后\");\n\n    println!(\"receive {}\", rx.recv().unwrap());\n    handle.join().unwrap();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117230344-8n0lp59","Type":"NodeParagraph","Properties":{"id":"20251117230344-8n0lp59","updated":"20251117230353"},"Children":[{"Type":"NodeText","Data":"从输出还可以看出，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"发送之前"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"发送之后"},{"Type":"NodeText","Data":"​是连续输出的，没有受到接收端主线程的任何影响，因此通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mpsc::channel"},{"Type":"NodeText","Data":"​创建的通道是异步通道。"}]},{"ID":"20251117230359-fgrpk7z","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251117230359-fgrpk7z","updated":"20251118205933"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E5%90%8C%E6%AD%A5%E9%80%9A%E9%81%93","TextMarkTextContent":"同步通道"}]},{"ID":"20251117230405-rdd194f","Type":"NodeParagraph","Properties":{"id":"20251117230405-rdd194f","updated":"20251117230405"},"Children":[{"Type":"NodeText","Data":"与异步通道相反，同步通道"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"发送消息是阻塞的，只有在消息被接收后才解除阻塞"},{"Type":"NodeText","Data":"，例如："}]},{"ID":"20251117230400-cmksu38","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251117230400-cmksu38","updated":"20251118205933"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nfn main() {\n    let (tx, rx)= mpsc::sync_channel(0); //容量\n\n    let handle = thread::spawn(move || {\n        println!(\"发送之前\");\n        tx.send(1).unwrap();\n        println!(\"发送之后\");\n    });\n\n    println!(\"睡眠之前\");\n    thread::sleep(Duration::from_secs(3));\n    println!(\"睡眠之后\");\n\n    println!(\"receive {}\", rx.recv().unwrap());\n    handle.join().unwrap();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251117230520-mcnysol","Type":"NodeList","ListData":{},"Properties":{"id":"20251117230520-mcnysol","updated":"20251117230520"},"Children":[{"ID":"20251117230520-yjsuf3d","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117230520-yjsuf3d","updated":"20251117230520"},"Children":[{"ID":"20251117230520-y96dzsd","Type":"NodeParagraph","Properties":{"id":"20251117230520-y96dzsd","updated":"20251117230520"},"Children":[{"Type":"NodeText","Data":"异步通道：​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"仅接收端阻塞"},{"Type":"NodeText","Data":"​，发送端通常不阻塞（依赖动态缓冲区）。"}]}]},{"ID":"20251117230520-ouhwzfe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251117230520-ouhwzfe","updated":"20251117230520"},"Children":[{"ID":"20251117230520-106e4i3","Type":"NodeParagraph","Properties":{"id":"20251117230520-106e4i3","updated":"20251117230520"},"Children":[{"Type":"NodeText","Data":"同步通道：​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"发送端和接收端都可能阻塞"},{"Type":"NodeText","Data":"​（发送端在缓冲区满时阻塞，接收端在无消息时阻塞）。"}]}]}]},{"ID":"20251118205927-io5eqm1","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251118205927-io5eqm1","updated":"20251118210026"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98","TextMarkTextContent":"消息缓存"}]},{"ID":"20251118205935-thtywu2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118205935-thtywu2","updated":"20251118210025"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let (tx, rx)= mpsc::sync_channel(0); //容量 ，如果是0，send就会一直阻塞到有recv，如果是n大于零则可以做n个缓存一直发送到满\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118210513-6jd4r5l","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118210513-6jd4r5l","updated":"20251118210518"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93","TextMarkTextContent":"关闭通道"}]},{"ID":"20251118210513-8jw7v7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118210513-8jw7v7x","updated":"20251118210518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"所有发送者被drop或者所有接收者被drop后，通道会自动关闭。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118210633-cnk95s2","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118210633-cnk95s2","updated":"20251118211033"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E4%BC%A0%E8%BE%93%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE","TextMarkTextContent":"传输多种类型的数据"}]},{"ID":"20251118210634-uma3dai","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118210634-uma3dai","updated":"20251118211016"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"之前提到过，一个消息通道只能传输一种类型的数据，如果你想要传输多种类型的数据，可以为每个类型创建一个通道，你也可以使用枚举类型来实现：\nuse std::sync::mpsc::{self, Receiver, Sender};\n\nenum Fruit {\n    Apple(u8),\n    Orange(String)\n}\n\nfn main() {\n    let (tx, rx): (Sender\u003cFruit\u003e, Receiver\u003cFruit\u003e) = mpsc::channel();\n\n    tx.send(Fruit::Orange(\"sweet\".to_string())).unwrap();\n    tx.send(Fruit::Apple(2)).unwrap();\n\n    for _ in 0..2 {\n        match rx.recv().unwrap() {\n            Fruit::Apple(count) =\u003e println!(\"received {} apples\", count),\n            Fruit::Orange(flavor) =\u003e println!(\"received {} oranges\", flavor),\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118211032-zdxjruk","Type":"NodeParagraph","Properties":{"id":"20251118211032-zdxjruk","updated":"20251118211032"},"Children":[{"Type":"NodeText","Data":"Rust 会按照枚举中占用内存最大的那个成员进行内存对齐，这意味着就算你传输的是枚举中占用内存最小的成员，它占用的内存依然和最大的成员相同, 因此会造成内存上的浪费。"}]},{"ID":"20251118211857-163hfjg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118211857-163hfjg","updated":"20251118213511"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%96%B0%E6%89%8B%E5%AE%B9%E6%98%93%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91","TextMarkTextContent":"新手容易遇到的坑"}]},{"ID":"20251118211857-iyq1z9f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118211857-iyq1z9f","updated":"20251118211946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::mpsc;\nfn main() {\n\n    use std::thread;\n\n    let (send, recv) = mpsc::channel(); //主线程的send 没有释放掉哟\n    let num_threads = 3;\n    for i in 0..num_threads {\n        let thread_send = send.clone();\n        thread::spawn(move || {\n            thread_send.send(i).unwrap();\n            println!(\"thread {:?} finished\", i);\n        });\n    }\n\n    // 在这里drop send...\n\n    for x in recv {\n        println!(\"Got: {}\", x);  //send一日不除，recv一直等send死\n    }\n    println!(\"finished iterating\");\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118213512-1u4c18h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118213512-1u4c18h","updated":"20251118213546"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/message-passing.html#mpmc-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD","TextMarkTextContent":"mpmc 更好的性能"}]},{"ID":"20251118213515-5ms7l7v","Type":"NodeParagraph","Properties":{"id":"20251118213515-5ms7l7v","updated":"20251118213515"},"Children":[{"Type":"NodeText","Data":"如果你需要 mpmc(多发送者，多接收者)或者需要更高的性能，可以考虑第三方库:"}]},{"ID":"20251118213515-vahv12p","Type":"NodeList","ListData":{},"Properties":{"id":"20251118213515-vahv12p","updated":"20251118213515"},"Children":[{"ID":"20251118213515-941yj75","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118213515-941yj75","updated":"20251118213515"},"Children":[{"ID":"20251118213515-irsvtac","Type":"NodeParagraph","Properties":{"id":"20251118213515-irsvtac","updated":"20251118213515"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a strong","TextMarkAHref":"https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel","TextMarkTextContent":"crossbeam-channel"},{"Type":"NodeText","Data":", 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"crossbeam"},{"Type":"NodeText","Data":"​主仓库中"}]}]},{"ID":"20251118213515-rdzde1a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118213515-rdzde1a","updated":"20251118213515"},"Children":[{"ID":"20251118213515-6ay120o","Type":"NodeParagraph","Properties":{"id":"20251118213515-6ay120o","updated":"20251118213515"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a strong","TextMarkAHref":"https://github.com/zesterer/flume","TextMarkTextContent":"flume"},{"Type":"NodeText","Data":", 官方给出的性能数据某些场景要比 crossbeam 更好些"}]}]}]},{"ID":"20251118213546-imvlvsa","Type":"NodeParagraph","Properties":{"id":"20251118213546-imvlvsa","updated":"20251118213546"}}]}