{"ID":"20251118224656-bj0q16w","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251118224656-bj0q16w","title":"线程同步：锁、Condvar 和信号量","type":"doc","updated":"20251118231809"},"Children":[{"ID":"20251118224656-862hgrr","Type":"NodeParagraph","Properties":{"id":"20251118224656-862hgrr","updated":"20251118225052"},"Children":[{"Type":"NodeText","Data":"在 Rust 中有多种方式可以实现同步。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。"}]},{"ID":"20251118225056-cmin4h0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118225056-cmin4h0","updated":"20251118225452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9","TextMarkTextContent":"该如何选择"}]},{"ID":"20251118225107-lh8gnq7","Type":"NodeParagraph","Properties":{"id":"20251118225107-lh8gnq7","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下："}]},{"ID":"20251118225107-l4facqr","Type":"NodeList","ListData":{},"Properties":{"id":"20251118225107-l4facqr","updated":"20251118225107"},"Children":[{"ID":"20251118225107-u1hvuzk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-u1hvuzk","updated":"20251118225107"},"Children":[{"ID":"20251118225107-fvod9go","Type":"NodeParagraph","Properties":{"id":"20251118225107-fvod9go","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存相对消息传递能节省多次内存拷贝的成本"}]}]},{"ID":"20251118225107-kgexaiz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-kgexaiz","updated":"20251118225107"},"Children":[{"ID":"20251118225107-t0epn8s","Type":"NodeParagraph","Properties":{"id":"20251118225107-t0epn8s","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存的实现简洁的多"}]}]},{"ID":"20251118225107-jtga1vg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-jtga1vg","updated":"20251118225107"},"Children":[{"ID":"20251118225107-9tykv5t","Type":"NodeParagraph","Properties":{"id":"20251118225107-9tykv5t","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存的锁竞争更多"}]}]}]},{"ID":"20251118225426-3bek5z3","Type":"NodeParagraph","Properties":{"id":"20251118225426-3bek5z3","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"消息传递适用的场景很多，我们下面列出了几个主要的使用场景:"}]},{"ID":"20251118225426-02e5r4y","Type":"NodeList","ListData":{},"Properties":{"id":"20251118225426-02e5r4y","updated":"20251118225426"},"Children":[{"ID":"20251118225426-0pi125f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-0pi125f","updated":"20251118225426"},"Children":[{"ID":"20251118225426-50zg28x","Type":"NodeParagraph","Properties":{"id":"20251118225426-50zg28x","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要可靠和简单的(简单不等于简洁)实现时"}]}]},{"ID":"20251118225426-fviibf4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-fviibf4","updated":"20251118225426"},"Children":[{"ID":"20251118225426-8tal26l","Type":"NodeParagraph","Properties":{"id":"20251118225426-8tal26l","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时"}]}]},{"ID":"20251118225426-xcdazfq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-xcdazfq","updated":"20251118225426"},"Children":[{"ID":"20251118225426-0gkatss","Type":"NodeParagraph","Properties":{"id":"20251118225426-0gkatss","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要一个任务处理流水线(管道)时，等等"}]}]}]},{"ID":"20251118225450-6f57q6d","Type":"NodeParagraph","Properties":{"id":"20251118225450-6f57q6d","updated":"20251118225450"},"Children":[{"Type":"NodeText","Data":"而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。"}]},{"ID":"20251118225450-lhvwvrv","Type":"NodeParagraph","Properties":{"id":"20251118225450-lhvwvrv","updated":"20251118225450"},"Children":[{"Type":"NodeText","Data":"总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。"}]},{"ID":"20251118225457-ycnf0yl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118225457-ycnf0yl","updated":"20251118231809"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E4%BA%92%E6%96%A5%E9%94%81-mutex","TextMarkTextContent":"互斥锁 Mutex"}]},{"ID":"20251118231111-ics0s20","Type":"NodeParagraph","Properties":{"id":"20251118231111-ics0s20","updated":"20251118231113"},"Children":[{"Type":"NodeText","Data":"单线程锁"}]},{"ID":"20251118225458-jxfyld0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118225458-jxfyld0","updated":"20251118231236"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Mutex;\n\nfn main() {\n    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例\n    let m = Mutex::new(5); //m是 Mutex\u003ci32\u003e的一个智能指针\n\n    {\n        // 获取锁，然后deref为`m`的引用\n        // lock返回的是Result\n        let mut num = m.lock().unwrap();  //num是m数据的一个临时访问入口\n        *num = 6;\n        // 锁自动被drop\n    }\n    println!(\"m = {:?}\", m);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118231350-g7joeq7","Type":"NodeParagraph","Properties":{"id":"20251118231350-g7joeq7","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"m.lock()"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法也有可能报错"},{"Type":"NodeText","Data":"​，例如当前正在持有锁的线程"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"panic"},{"Type":"NodeText","Data":"​了。在这种情况下，其它线程不可能再获得锁，因此"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"​方法会返回一个错误。"}]},{"ID":"20251118231350-frlz8k9","Type":"NodeParagraph","Properties":{"id":"20251118231350-frlz8k9","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"这里你可能奇怪，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.lock"},{"Type":"NodeText","Data":"​明明返回一个锁，怎么就变成我们的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"num"},{"Type":"NodeText","Data":"​数值了？聪明的读者可能会想到智能指针，没错，因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​是一个智能指针，准确的说是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.lock()"},{"Type":"NodeText","Data":"​返回一个智能指针"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MutexGuard\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​:"}]},{"ID":"20251118231350-zak1vcf","Type":"NodeList","ListData":{},"Properties":{"id":"20251118231350-zak1vcf","updated":"20251118231350"},"Children":[{"ID":"20251118231350-lzlaodx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118231350-lzlaodx","updated":"20251118231350"},"Children":[{"ID":"20251118231350-8u5yv28","Type":"NodeParagraph","Properties":{"id":"20251118231350-8u5yv28","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"它实现了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​特征，会被自动解引用后获得一个引用类型，该引用指向"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​内部的数据"}]}]},{"ID":"20251118231350-7l2twdl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118231350-7l2twdl","updated":"20251118231350"},"Children":[{"ID":"20251118231350-ypv7p6p","Type":"NodeParagraph","Properties":{"id":"20251118231350-ypv7p6p","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"它还实现了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁"}]}]}]},{"ID":"20251118231354-1byqlko","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118231354-1byqlko","updated":"20251118231809"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    let mut num = m.lock().unwrap();\n    *num = 6;\n    // 锁还没有被 drop 就尝试申请下一个锁，导致主线程阻塞\n    // drop(num); // 手动 drop num ，可以让 num1 申请到下个锁  //不drop就死锁\n    let mut num1 = m.lock().unwrap();\n    *num1 = 7;\n    // drop(num1); // 手动 drop num1 ，观察打印结果的不同  //不drop就取不到值，可以直接拿num1的值\n\n    println!(\"m = {:?}\", m); //debug遵循了锁特征，读取要拿锁\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118231620-j6ayb9b","Type":"NodeParagraph","Properties":{"id":"20251118231620-j6ayb9b","updated":"20251118231620"}}]}