{"ID":"20251118224656-bj0q16w","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251118224656-bj0q16w","title":"线程同步：锁、Condvar 和信号量","type":"doc","updated":"20251119230912"},"Children":[{"ID":"20251118224656-862hgrr","Type":"NodeParagraph","Properties":{"id":"20251118224656-862hgrr","updated":"20251118225052"},"Children":[{"Type":"NodeText","Data":"在 Rust 中有多种方式可以实现同步。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。"}]},{"ID":"20251118225056-cmin4h0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118225056-cmin4h0","updated":"20251118225452"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9","TextMarkTextContent":"该如何选择"}]},{"ID":"20251118225107-lh8gnq7","Type":"NodeParagraph","Properties":{"id":"20251118225107-lh8gnq7","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下："}]},{"ID":"20251118225107-l4facqr","Type":"NodeList","ListData":{},"Properties":{"id":"20251118225107-l4facqr","updated":"20251118225107"},"Children":[{"ID":"20251118225107-u1hvuzk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-u1hvuzk","updated":"20251118225107"},"Children":[{"ID":"20251118225107-fvod9go","Type":"NodeParagraph","Properties":{"id":"20251118225107-fvod9go","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存相对消息传递能节省多次内存拷贝的成本"}]}]},{"ID":"20251118225107-kgexaiz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-kgexaiz","updated":"20251118225107"},"Children":[{"ID":"20251118225107-t0epn8s","Type":"NodeParagraph","Properties":{"id":"20251118225107-t0epn8s","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存的实现简洁的多"}]}]},{"ID":"20251118225107-jtga1vg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225107-jtga1vg","updated":"20251118225107"},"Children":[{"ID":"20251118225107-9tykv5t","Type":"NodeParagraph","Properties":{"id":"20251118225107-9tykv5t","updated":"20251118225107"},"Children":[{"Type":"NodeText","Data":"共享内存的锁竞争更多"}]}]}]},{"ID":"20251118225426-3bek5z3","Type":"NodeParagraph","Properties":{"id":"20251118225426-3bek5z3","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"消息传递适用的场景很多，我们下面列出了几个主要的使用场景:"}]},{"ID":"20251118225426-02e5r4y","Type":"NodeList","ListData":{},"Properties":{"id":"20251118225426-02e5r4y","updated":"20251118225426"},"Children":[{"ID":"20251118225426-0pi125f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-0pi125f","updated":"20251118225426"},"Children":[{"ID":"20251118225426-50zg28x","Type":"NodeParagraph","Properties":{"id":"20251118225426-50zg28x","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要可靠和简单的(简单不等于简洁)实现时"}]}]},{"ID":"20251118225426-fviibf4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-fviibf4","updated":"20251118225426"},"Children":[{"ID":"20251118225426-8tal26l","Type":"NodeParagraph","Properties":{"id":"20251118225426-8tal26l","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时"}]}]},{"ID":"20251118225426-xcdazfq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118225426-xcdazfq","updated":"20251118225426"},"Children":[{"ID":"20251118225426-0gkatss","Type":"NodeParagraph","Properties":{"id":"20251118225426-0gkatss","updated":"20251118225426"},"Children":[{"Type":"NodeText","Data":"需要一个任务处理流水线(管道)时，等等"}]}]}]},{"ID":"20251118225450-6f57q6d","Type":"NodeParagraph","Properties":{"id":"20251118225450-6f57q6d","updated":"20251118225450"},"Children":[{"Type":"NodeText","Data":"而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。"}]},{"ID":"20251118225450-lhvwvrv","Type":"NodeParagraph","Properties":{"id":"20251118225450-lhvwvrv","updated":"20251118225450"},"Children":[{"Type":"NodeText","Data":"总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。"}]},{"ID":"20251118225457-ycnf0yl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251118225457-ycnf0yl","updated":"20251119221513"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E4%BA%92%E6%96%A5%E9%94%81-mutex","TextMarkTextContent":"互斥锁 Mutex"}]},{"ID":"20251118231111-ics0s20","Type":"NodeParagraph","Properties":{"id":"20251118231111-ics0s20","updated":"20251118231113"},"Children":[{"Type":"NodeText","Data":"单线程锁"}]},{"ID":"20251118225458-jxfyld0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118225458-jxfyld0","updated":"20251118231236"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Mutex;\n\nfn main() {\n    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例\n    let m = Mutex::new(5); //m是 Mutex\u003ci32\u003e的一个智能指针\n\n    {\n        // 获取锁，然后deref为`m`的引用\n        // lock返回的是Result\n        let mut num = m.lock().unwrap();  //num是m数据的一个临时访问入口\n        *num = 6;\n        // 锁自动被drop\n    }\n    println!(\"m = {:?}\", m);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251118231350-g7joeq7","Type":"NodeParagraph","Properties":{"id":"20251118231350-g7joeq7","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"m.lock()"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"方法也有可能报错"},{"Type":"NodeText","Data":"​，例如当前正在持有锁的线程"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"panic"},{"Type":"NodeText","Data":"​了。在这种情况下，其它线程不可能再获得锁，因此"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"​方法会返回一个错误。"}]},{"ID":"20251118231350-frlz8k9","Type":"NodeParagraph","Properties":{"id":"20251118231350-frlz8k9","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"这里你可能奇怪，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.lock"},{"Type":"NodeText","Data":"​明明返回一个锁，怎么就变成我们的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"num"},{"Type":"NodeText","Data":"​数值了？聪明的读者可能会想到智能指针，没错，因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​是一个智能指针，准确的说是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"m.lock()"},{"Type":"NodeText","Data":"​返回一个智能指针"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MutexGuard\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​:"}]},{"ID":"20251118231350-zak1vcf","Type":"NodeList","ListData":{},"Properties":{"id":"20251118231350-zak1vcf","updated":"20251118231350"},"Children":[{"ID":"20251118231350-lzlaodx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118231350-lzlaodx","updated":"20251118231350"},"Children":[{"ID":"20251118231350-8u5yv28","Type":"NodeParagraph","Properties":{"id":"20251118231350-8u5yv28","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"它实现了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​特征，会被自动解引用后获得一个引用类型，该引用指向"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​内部的数据"}]}]},{"ID":"20251118231350-7l2twdl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251118231350-7l2twdl","updated":"20251118231350"},"Children":[{"ID":"20251118231350-ypv7p6p","Type":"NodeParagraph","Properties":{"id":"20251118231350-ypv7p6p","updated":"20251118231350"},"Children":[{"Type":"NodeText","Data":"它还实现了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁"}]}]}]},{"ID":"20251118231354-1byqlko","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251118231354-1byqlko","updated":"20251118231809"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    let mut num = m.lock().unwrap();\n    *num = 6;\n    // 锁还没有被 drop 就尝试申请下一个锁，导致主线程阻塞\n    // drop(num); // 手动 drop num ，可以让 num1 申请到下个锁  //不drop就死锁\n    let mut num1 = m.lock().unwrap();\n    *num1 = 7;\n    // drop(num1); // 手动 drop num1 ，观察打印结果的不同  //不drop就取不到值，可以直接拿num1的值\n\n    println!(\"m = {:?}\", m); //debug遵循了锁特征，读取要拿锁\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119215611-3cltk2x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251119215611-3cltk2x","updated":"20251119221513"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-mutex","TextMarkTextContent":"多线程中使用 Mutex"}]},{"ID":"20251119221459-qlhoy2n","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20251119221459-qlhoy2n","updated":"20251119221513"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E7%9A%84rct","TextMarkTextContent":"无法运行的"},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E7%9A%84rct","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251119215612-8fv4y3w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119215612-8fv4y3w","updated":"20251119221513"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    // 通过`Rc`实现`Mutex`的多所有权\n    let counter = Rc::new(Mutex::new(0));  //会报错！！！rc不支持跨线程\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(\u0026counter);\n        // 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    // 等待所有子线程完成\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // 输出最终的计数结果\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119221524-9neqcb3","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20251119221524-9neqcb3","updated":"20251119221550"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-arct","TextMarkTextContent":"多线程安全的 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-arct","TextMarkTextContent":"Arc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251119221525-3gauwjg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119221525-3gauwjg","updated":"20251119221534"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(\u0026counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119221807-oxkusll","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251119221807-oxkusll","updated":"20251119221814"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7","TextMarkTextContent":"内部可变性"}]},{"ID":"20251119221808-4akh579","Type":"NodeParagraph","Properties":{"id":"20251119221808-4akh579","updated":"20251119221813"},"Children":[{"Type":"NodeText","Data":"简单总结下："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;/RefCell\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​用于单线程内部可变性， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc\u0026lt;T\u0026gt;/Mutex\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​用于多线程内部可变性。"}]},{"ID":"20251119222531-8jsz09d","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119222531-8jsz09d","updated":"20251119222547"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E6%AD%BB%E9%94%81","TextMarkTextContent":"死锁"}]},{"ID":"20251119222538-1q9hkdg","Type":"NodeParagraph","Properties":{"id":"20251119222538-1q9hkdg","updated":"20251119222539"},"Children":[{"Type":"NodeText","Data":"在 Rust 中有多种方式可以创建死锁，了解这些方式有助于你提前规避可能的风险，一起来看看。"}]},{"ID":"20251119222542-w4lpx6v","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251119222542-w4lpx6v","updated":"20251119222547"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81","TextMarkTextContent":"单线程死锁"}]},{"ID":"20251119222542-br10qek","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119222542-br10qek","updated":"20251119222547"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Mutex;\n\nfn main() {\n    let data = Mutex::new(0);\n    let d1 = data.lock();\n    let d2 = data.lock();\n} // d1锁在此处释放\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119222801-raudtg7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251119222801-raudtg7","updated":"20251119222944"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81","TextMarkTextContent":"多线程死锁"}]},{"ID":"20251119222802-k3b13fv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119222802-k3b13fv","updated":"20251119222944"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"太多了不想写\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119222953-3313ehi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251119222953-3313ehi","updated":"20251119223701"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#try_lock","TextMarkTextContent":"try_lock"}]},{"ID":"20251119223056-b2k69pb","Type":"NodeParagraph","Properties":{"id":"20251119223056-b2k69pb","updated":"20251119223057"},"Children":[{"Type":"NodeText","Data":"与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lock"},{"Type":"NodeText","Data":"​方法不同，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_lock"},{"Type":"NodeText","Data":"​会"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"尝试"},{"Type":"NodeText","Data":"去获取一次锁，如果无法获取会返回一个错误，因此"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"不会发生阻塞"},{"Type":"NodeText","Data":":"}]},{"ID":"20251119222953-oaers44","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119222953-oaers44","updated":"20251119223059"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::{sync::{Mutex, MutexGuard}, thread};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nuse lazy_static::lazy_static;\nlazy_static! {\n    static ref MUTEX1: Mutex\u003ci64\u003e = Mutex::new(0);\n    static ref MUTEX2: Mutex\u003ci64\u003e = Mutex::new(0);\n}\n\nfn main() {\n    // 存放子线程的句柄\n    let mut children = vec![];\n    for i_thread in 0..2 {\n        children.push(thread::spawn(move || {\n            for _ in 0..1 {\n                // 线程1\n                if i_thread % 2 == 0 {\n                    // 锁住MUTEX1\n                    let guard: MutexGuard\u003ci64\u003e = MUTEX1.lock().unwrap();\n\n                    println!(\"线程 {} 锁住了MUTEX1，接着准备去锁MUTEX2 !\", i_thread);\n\n                    // 当前线程睡眠一小会儿，等待线程2锁住MUTEX2\n                    sleep(Duration::from_millis(10));\n\n                    // 去锁MUTEX2\n                    let guard = MUTEX2.try_lock();\n                    println!(\"线程 {} 获取 MUTEX2 锁的结果: {:?}\", i_thread, guard);\n                // 线程2\n                } else {\n                    // 锁住MUTEX2\n                    let _guard = MUTEX2.lock().unwrap();\n\n                    println!(\"线程 {} 锁住了MUTEX2, 准备去锁MUTEX1\", i_thread);\n                    sleep(Duration::from_millis(10));\n                    let guard = MUTEX1.try_lock();\n                    println!(\"线程 {} 获取 MUTEX1 锁的结果: {:?}\", i_thread, guard);\n                }\n            }\n        }));\n    }\n\n    // 等子线程完成\n    for child in children {\n        let _ = child.join();\n    }\n\n    println!(\"死锁没有发生\");\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119223700-jnb946j","Type":"NodeParagraph","Properties":{"id":"20251119223700-jnb946j","updated":"20251119223701"},"Children":[{"Type":"NodeText","Data":"当"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_lock"},{"Type":"NodeText","Data":"​失败时，会报出一个错误:"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Err(\"WouldBlock\")"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251119223131-0pcp19u","Type":"NodeParagraph","Properties":{"id":"20251119223131-0pcp19u","updated":"20251119223131"},"Children":[{"Type":"NodeText","Data":"一个有趣的命名规则：在 Rust 标准库中，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_xxx"},{"Type":"NodeText","Data":"​都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。例如消息传递章节中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_recv"},{"Type":"NodeText","Data":"​以及本章节中的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_lock"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251119223134-4hzcqm8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119223134-4hzcqm8","updated":"20251119224157"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E8%AF%BB%E5%86%99%E9%94%81-rwlock","TextMarkTextContent":"读写锁 RwLock"}]},{"ID":"20251119223321-1kky6gf","Type":"NodeParagraph","Properties":{"id":"20251119223321-1kky6gf","updated":"20251119223321"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​就无法满足需求了，此时就可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​:"}]},{"ID":"20251119223135-nrgvdu8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119223135-nrgvdu8","updated":"20251119223324"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::RwLock;\n\nfn main() {\n    let lock = RwLock::new(5);\n\n    // 同一时间允许多个读\n    {\n        let r1 = lock.read().unwrap();\n        let r2 = lock.read().unwrap();\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    } // 读锁在此处被drop\n\n    // 同一时间只允许一个写\n    {\n        let mut w = lock.write().unwrap();\n        *w += 1;\n        assert_eq!(*w, 6);\n\n        // 以下代码会阻塞发生死锁，因为读和写不允许同时存在\n        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中\n        // let r1 = lock.read();\n        // println!(\"{:?}\",r1);\n    }// 写锁在此处被drop\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119224157-8l1fvf6","Type":"NodeParagraph","Properties":{"id":"20251119224157-8l1fvf6","updated":"20251119224157"}},{"ID":"20251119224157-b36t1em","Type":"NodeTable","TableAligns":[1,1,1],"Properties":{"colgroup":"||","id":"20251119224157-b36t1em","updated":"20251119224157"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"场景"}]},{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"处理方式"}]},{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"通俗理解"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"两个线程同时写"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"互斥（排队执行）"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"写操作是 “独占的”，只能一个写完另一个再写"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"两个线程同时读"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"并发（同时执行）"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"读操作是 “共享的”，多个线程一起读不冲突"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"一个线程写、一个线程读"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"互斥（写优先 / 读优先，看实现）"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"写的时候不能读，读的时候不能写，必须等对方释放锁"}]}]}]},{"ID":"20251119223640-gko7l0m","Type":"NodeParagraph","Properties":{"id":"20251119223640-gko7l0m","updated":"20251119223645"},"Children":[{"Type":"NodeText","Data":"我们也可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_write"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_read"},{"Type":"NodeText","Data":"​来尝试进行一次写/读，若失败则返回错误:"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Err(\"WouldBlock\")"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251119223711-zkvojei","Type":"NodeParagraph","Properties":{"id":"20251119223711-zkvojei","updated":"20251119223711"},"Children":[{"Type":"NodeText","Data":"简单总结下"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​:"}]},{"ID":"20251119223711-gmo0wf9","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251119223711-gmo0wf9","updated":"20251119223711"},"Children":[{"ID":"20251119223711-xu6woei","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251119223711-xu6woei","updated":"20251119223711"},"Children":[{"ID":"20251119223711-z4l9lhc","Type":"NodeParagraph","Properties":{"id":"20251119223711-z4l9lhc","updated":"20251119223711"},"Children":[{"Type":"NodeText","Data":"同时允许多个读，但最多只能有一个写"}]}]},{"ID":"20251119223711-wiqubxk","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251119223711-wiqubxk","updated":"20251119223711"},"Children":[{"ID":"20251119223711-s9ti4n5","Type":"NodeParagraph","Properties":{"id":"20251119223711-s9ti4n5","updated":"20251119223711"},"Children":[{"Type":"NodeText","Data":"读和写不能同时存在"}]}]},{"ID":"20251119223711-70cu6xa","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251119223711-70cu6xa","updated":"20251119223711"},"Children":[{"ID":"20251119223711-g7uln71","Type":"NodeParagraph","Properties":{"id":"20251119223711-g7uln71","updated":"20251119223711"},"Children":[{"Type":"NodeText","Data":"读可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"read"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_read"},{"Type":"NodeText","Data":"​，写"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"write"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_write"},{"Type":"NodeText","Data":"​, 在实际项目中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_xxx"},{"Type":"NodeText","Data":"​会安全的多"}]}]}]},{"ID":"20251119223749-w0b0ioj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119223749-w0b0ioj","updated":"20251119224242"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#mutex-%E8%BF%98%E6%98%AF-rwlock","TextMarkTextContent":"Mutex 还是 RwLock"}]},{"ID":"20251119223811-953j6p7","Type":"NodeParagraph","Properties":{"id":"20251119223811-953j6p7","updated":"20251119223811"},"Children":[{"Type":"NodeText","Data":"首先简单性上"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​完胜，因为使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​你得操心几个问题："}]},{"ID":"20251119223811-er8nv7z","Type":"NodeList","ListData":{},"Properties":{"id":"20251119223811-er8nv7z","updated":"20251119223811"},"Children":[{"ID":"20251119223811-coe11he","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223811-coe11he","updated":"20251119223811"},"Children":[{"ID":"20251119223811-j3u4pr0","Type":"NodeParagraph","Properties":{"id":"20251119223811-j3u4pr0","updated":"20251119223811"},"Children":[{"Type":"NodeText","Data":"读和写不能同时发生，如果使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"try_xxx"},{"Type":"NodeText","Data":"​解决，就必须做大量的错误处理和失败重试机制"}]}]},{"ID":"20251119223811-n7im8gh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223811-n7im8gh","updated":"20251119223811"},"Children":[{"ID":"20251119223811-dt269g3","Type":"NodeParagraph","Properties":{"id":"20251119223811-dt269g3","updated":"20251119223811"},"Children":[{"Type":"NodeText","Data":"当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败("},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://stackoverflow.com/questions/2190090/how-to-prevent-writer-starvation-in-a-read-write-lock-in-pthreads","TextMarkTextContent":"writer starvation"},{"Type":"NodeText","Data":")"}]}]},{"ID":"20251119223811-5obzxax","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223811-5obzxax","updated":"20251119223811"},"Children":[{"ID":"20251119223811-sm61hcm","Type":"NodeParagraph","Properties":{"id":"20251119223811-sm61hcm","updated":"20251119223811"},"Children":[{"Type":"NodeText","Data":"RwLock 其实是操作系统提供的，实现原理要比"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​复杂的多，因此单就锁的性能而言，比不上原生实现的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20251119223823-68njvra","Type":"NodeParagraph","Properties":{"id":"20251119223823-68njvra","updated":"20251119223823"},"Children":[{"Type":"NodeText","Data":"再来简单总结下两者的使用场景："}]},{"ID":"20251119223823-m901gwn","Type":"NodeList","ListData":{},"Properties":{"id":"20251119223823-m901gwn","updated":"20251119223823"},"Children":[{"ID":"20251119223823-q9h58c3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223823-q9h58c3","updated":"20251119223823"},"Children":[{"ID":"20251119223823-k6u371e","Type":"NodeParagraph","Properties":{"id":"20251119223823-k6u371e","updated":"20251119223823"},"Children":[{"Type":"NodeText","Data":"追求高并发读取时，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​，因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​一次只允许一个线程去读取"}]}]},{"ID":"20251119223823-ra787gw","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223823-ra787gw","updated":"20251119223823"},"Children":[{"ID":"20251119223823-yh6nulr","Type":"NodeParagraph","Properties":{"id":"20251119223823-yh6nulr","updated":"20251119223823"},"Children":[{"Type":"NodeText","Data":"如果要保证写操作的成功性，使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251119223823-v9mp4ht","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119223823-v9mp4ht","updated":"20251119223823"},"Children":[{"ID":"20251119223823-fwwydmi","Type":"NodeParagraph","Properties":{"id":"20251119223823-fwwydmi","updated":"20251119223823"},"Children":[{"Type":"NodeText","Data":"不知道哪个合适，统一使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20251119223934-s346cdt","Type":"NodeParagraph","Properties":{"id":"20251119223934-s346cdt","updated":"20251119223934"},"Children":[{"Type":"NodeText","Data":"一个常见的、错误的使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​的场景就是使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​进行简单读写，因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​的读和写都非常快，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​的复杂实现和相对低的性能反而会导致整体性能的降低，因此一般来说更适合使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20251119223947-t7jofmb","Type":"NodeParagraph","Properties":{"id":"20251119223947-t7jofmb","updated":"20251119223947"},"Children":[{"Type":"NodeText","Data":"需要注意的是，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​虽然看上去貌似提供了高并发读取的能力，但这个不能说明它的性能比"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​高，事实上"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​性能要好不少，后者"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"唯一的问题也仅仅在于不能并发读取"},{"Type":"NodeText","Data":"。"}]},{"ID":"20251119223934-m3vfyl1","Type":"NodeParagraph","Properties":{"id":"20251119223934-m3vfyl1","updated":"20251119223934"},"Children":[{"Type":"NodeText","Data":"总之，如果你要使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RwLock"},{"Type":"NodeText","Data":"​要确保满足以下两个条件："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"并发读，且需要对读到的资源进行\"长时间\"的操作"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"HashMap"},{"Type":"NodeText","Data":"​也许满足了并发读的需求，但是往往并不能满足后者：\"长时间\"的操作。"}]},{"ID":"20251119224242-pe45mlu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119224242-pe45mlu","updated":"20251119224258"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E4%B8%89%E6%96%B9%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E5%AE%9E%E7%8E%B0","TextMarkTextContent":"三方库提供的锁实现"}]},{"ID":"20251119224146-mi2c3mp","Type":"NodeParagraph","Properties":{"id":"20251119224146-mi2c3mp","updated":"20251119224235"},"Children":[{"Type":"NodeText","Data":"标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:"}]},{"ID":"20251119224247-gx4hk48","Type":"NodeList","ListData":{},"Properties":{"id":"20251119224247-gx4hk48","updated":"20251119224247"},"Children":[{"ID":"20251119224247-2o4q746","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119224247-2o4q746","updated":"20251119224247"},"Children":[{"ID":"20251119224247-0spvaoc","Type":"NodeParagraph","Properties":{"id":"20251119224247-0spvaoc","updated":"20251119224247"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://crates.io/crates/parking_lot","TextMarkTextContent":"parking_lot"},{"Type":"NodeText","Data":", 功能更完善、稳定，社区较为活跃，star 较多，更新较为活跃"}]}]},{"ID":"20251119224247-1gafugo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251119224247-1gafugo","updated":"20251119224247"},"Children":[{"ID":"20251119224247-izp7ep0","Type":"NodeParagraph","Properties":{"id":"20251119224247-izp7ep0","updated":"20251119224247"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://crates.io/crates/spin","TextMarkTextContent":"spin"},{"Type":"NodeText","Data":", 在多数场景中性能比"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"parking_lot"},{"Type":"NodeText","Data":"​高一点，最近没怎么更新"}]}]}]},{"ID":"20251119224247-mteyati","Type":"NodeParagraph","Properties":{"id":"20251119224247-mteyati","updated":"20251119224247"},"Children":[{"Type":"NodeText","Data":"如果不是追求特别极致的性能，建议选择前者。"}]},{"ID":"20251119224258-p8eoh9m","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119224258-p8eoh9m","updated":"20251119225234"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondvar%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5","TextMarkTextContent":"用条件变量(Condvar)控制线程的同步"}]},{"ID":"20251119224259-jqtp9gr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119224259-jqtp9gr","updated":"20251119225234"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::{Arc,Mutex,Condvar};\nuse std::thread::{spawn,sleep};\nuse std::time::Duration;\n\nfn main() {\n    let flag = Arc::new(Mutex::new(false));\n    let cond = Arc::new(Condvar::new());\n    let cflag = flag.clone();\n    let ccond = cond.clone();\n\n    let hdl = spawn(move || {\n        let mut lock = cflag.lock().unwrap();\n        let mut counter = 0;\n\n        while counter \u003c 3 {\n            while !*lock {\n                // wait方法会接收一个MutexGuard\u003c'a, T\u003e，且它会自动地暂时释放这个锁，使其他线程可以拿到锁并进行数据更新。\n                // 同时当前线程在此处会被阻塞，直到被其他地方notify后，它会将原本的MutexGuard\u003c'a, T\u003e还给我们，即重新获取到了锁，同时唤醒了此线程。\n                lock = ccond.wait(lock).unwrap();\n            }\n            \n            *lock = false;\n\n            counter += 1;\n            println!(\"inner counter: {}\", counter);\n        }\n    });\n\n    let mut counter = 0;\n    loop {\n        sleep(Duration::from_millis(1000));  //去掉了就锁死了哟\n        *flag.lock().unwrap() = true;\n        counter += 1;\n        if counter \u003e 3 {\n            break;\n        }\n        println!(\"outside counter: {}\", counter);\n        cond.notify_one();\n    }\n    hdl.join().unwrap();\n    println!(\"{:?}\", flag);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119225240-1maqo39","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251119225240-1maqo39","updated":"20251119230912"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/concurrency-with-threads/sync1.html#%E4%BF%A1%E5%8F%B7%E9%87%8F-semaphore","TextMarkTextContent":"信号量 Semaphore"}]},{"ID":"20251119225653-ruwjsdx","Type":"NodeParagraph","Properties":{"id":"20251119225653-ruwjsdx","updated":"20251119225653"},"Children":[{"Type":"NodeText","Data":"可以让我们精准的控制当前正在运行的任务最大数量。想象一下，当一个新游戏刚开服时(有些较火的老游戏也会，比如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"wow"},{"Type":"NodeText","Data":"​)，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。"}]},{"ID":"20251119225643-vhv6iya","Type":"NodeParagraph","Properties":{"id":"20251119225643-vhv6iya","updated":"20251119225643"},"Children":[{"Type":"NodeText","Data":"本来 Rust 在标准库中有提供一个"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://doc.rust-lang.org/1.8.0/std/sync/struct.Semaphore.html","TextMarkTextContent":"信号量实现"},{"Type":"NodeText","Data":", 但是由于各种原因这个库现在已经不再推荐使用了，因此我们推荐使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"tokio"},{"Type":"NodeText","Data":"​中提供的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Semaphore"},{"Type":"NodeText","Data":"​实现: "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://github.com/tokio-rs/tokio/blob/master/tokio/src/sync/semaphore.rs","TextMarkTextContent":"tokio::sync::Semaphore"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20251119225241-63tukwe","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251119225241-63tukwe","updated":"20251119230912"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Arc;\nuse tokio::sync::Semaphore;\n\n#[tokio::main]\nasync fn main() {\n    let semaphore = Arc::new(Semaphore::new(3));\n    let mut join_handles = Vec::new();\n\n    for _ in 0..5 {\n        let permit = semaphore.clone().acquire_owned().await.unwrap();  //这里可以实现把信号量克隆，然后wait在线程里面做，要不然概念不清\n        join_handles.push(tokio::spawn(async move {\n            //\n            // 在这里执行任务...\n            //\n            drop(permit);\n        }));\n    }\n\n    for handle in join_handles {\n        handle.await.unwrap();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251119225654-fe1h67j","Type":"NodeParagraph","Properties":{"id":"20251119225654-fe1h67j","updated":"20251119225654"}}]}