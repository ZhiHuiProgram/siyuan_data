{"ID":"20251025094721-qyevbq4","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251025094721-qyevbq4","title":"类型转换","type":"doc","updated":"20251025110207"},"Children":[{"ID":"20251025094732-vtw3z8g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025094732-vtw3z8g","updated":"20251025095949"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#as%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"as"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#as%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"转换"}]},{"ID":"20251025094732-pvhz1rv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025094732-pvhz1rv","updated":"20251025095949"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let a = i8::MAX; let a = i32::MAX; //type max value\n   let a = 3.1 as i8;\n   let b = 100_i8 as i32;\n   let c = 'a' as u8; // 将字符'a'转换为整数，97\n内存地址转换为指针\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize; // 将p1内存地址转换为一个整数\nlet second_address = first_address + 4; // 4 == std::mem::size_of::\u003ci32\u003e()，i32类型占用4个字节，因此将内存地址 + 4\nlet p2 = second_address as *mut i32; // 访问该地址指向的下一个整数p2\nunsafe {\n\t//这里提供一个不安全的指针修改\n\t//let p2 = p1.add(1); 避免地址整数地址直接的转换\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);\n转换不具有传递性 就算 e as U1 as U2 是合法的，也不能说明 e as U2 是合法的（e 不能直接转换成 U2）\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025095320-9350931","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025095320-9350931","updated":"20251025100943"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#tryinto-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"TryInto"}]},{"ID":"20251025095321-7buwf74","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025095321-7buwf74","updated":"20251025100941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::convert::TryInto; //可以去掉，这个特征在prelude里面\nfn main() {\n    let b: i16 = 1500;\n\n    let b_: u8 = match b.try_into() {  //尝试转化为u8，但是值溢出了，会报错，这里可以使用unwrap，提取值，错误就panic\n        Ok(b1) =\u003e b1,\n        Err(e) =\u003e {\n            println!(\"{:?}\", e.to_string());\n            0\n        }\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025101005-bsh8fvm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025101005-bsh8fvm","updated":"20251025110207"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"通用类型转换"}]},{"ID":"20251025101005-0y9s9h2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025101005-0y9s9h2","updated":"20251025104924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"强制类型转换\n隐式的，比如参数是不可变借用，但是传入可变借用，会自动降级，等等\n// 1) Deref coercion：\u0026String → \u0026str\nfn takes_str(s: \u0026str) {}\nlet s = String::from(\"hi\");\ntakes_str(\u0026s); // 自动从 \u0026String 转为 \u0026str\n\n// 2) 借用降级：\u0026mut T → \u0026T\nfn takes_ref(x: \u0026i32) {}\nlet mut m = 1;\ntakes_ref(\u0026mut m); // 自动从 \u0026mut i32 转为 \u0026i32\n\n// 3) Unsizing：\u0026[T; N] → \u0026[T]（定长数组到切片）\nfn sum(slice: \u0026[i32]) -\u003e i32 { slice.iter().sum() }\nlet arr = [1, 2, 3];\nlet _ = sum(\u0026arr); // \u0026 [i32; 3] 自动变为 \u0026 [i32]\n\n// 4) 非捕获闭包 → 函数指针 fn(...)\nlet f: fn(i32) -\u003e i32 = |x| x + 1; // 自动从闭包到 fn 指针\nlet _ = f(3);\n\n// 5) 引用 → 原始指针\nlet x = 10;\nlet p_const: *const i32 = \u0026x;      // \u0026T → *const T\nlet mut y = 20;\nlet p_mut: *mut i32 = \u0026mut y;      // \u0026mut T → *mut T\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025105010-llw58ac","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251025105010-llw58ac","updated":"20251025110207"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6","TextMarkTextContent":"点操作符"}]},{"ID":"20251025105011-fct0z60","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025105011-fct0z60","linewrap":"true","updated":"20251025105402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"假设有一个方法 foo，它有一个接收器(接收器就是 self、\u0026self、\u0026mut self 参数)。如果调用 value.foo()，编译器在调用 foo 之前，需要决定到底使用哪个 Self 类型来调用。现在假设 value 拥有类型 T\t\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025105418-yzsb2er","Type":"NodeParagraph","Properties":{"id":"20251025105418-yzsb2er","updated":"20251025105436"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"完全限定语法"},{"Type":"NodeText","Data":"来进行准确的函数调用:"}]},{"ID":"20251025105353-w7ezgve","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251025105353-w7ezgve","updated":"20251025105353"},"Children":[{"ID":"20251025105353-mnd7lf5","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251025105353-mnd7lf5","updated":"20251025105353"},"Children":[{"ID":"20251025105353-n86liil","Type":"NodeParagraph","Properties":{"id":"20251025105353-n86liil","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"首先，编译器检查它是否可以直接调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T::foo(value)"},{"Type":"NodeText","Data":"​，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"值方法调用"}]}]},{"ID":"20251025105353-5iy1wnf","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251025105353-5iy1wnf","updated":"20251025105353"},"Children":[{"ID":"20251025105353-vmjqqwe","Type":"NodeParagraph","Properties":{"id":"20251025105353-vmjqqwe","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"如果上一步调用无法完成(例如方法类型错误或者特征没有针对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Self"},{"Type":"NodeText","Data":"​ 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，例如会尝试以下调用： "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026amp;T\u0026gt;::foo(value)"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026amp;mut T\u0026gt;::foo(value)"},{"Type":"NodeText","Data":"​，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"引用方法调用"}]}]},{"ID":"20251025105353-6zultuw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251025105353-6zultuw","updated":"20251025105353"},"Children":[{"ID":"20251025105353-pg6hdms","Type":"NodeParagraph","Properties":{"id":"20251025105353-pg6hdms","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若上面两个方法依然不工作，编译器会试着解引用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ ，然后再进行尝试。这里使用了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征 —— 若 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T: Deref\u0026lt;Target = U\u0026gt;"},{"Type":"NodeText","Data":"​ ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 可以被解引用为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"U"},{"Type":"NodeText","Data":"​)，那么编译器会使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"U"},{"Type":"NodeText","Data":"​ 类型进行尝试，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"解引用方法调用"}]}]},{"ID":"20251025105353-yqxb5er","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20251025105353-yqxb5er","updated":"20251025105353"},"Children":[{"ID":"20251025105353-060t8vx","Type":"NodeParagraph","Properties":{"id":"20251025105353-060t8vx","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 不能被解引用，且 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 从定长类型转为不定长类型，例如将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[i32; 2]"},{"Type":"NodeText","Data":"​ 转为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[i32]"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025105353-m1kke7w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20251025105353-m1kke7w","updated":"20251025105353"},"Children":[{"ID":"20251025105353-nausrhp","Type":"NodeParagraph","Properties":{"id":"20251025105353-nausrhp","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若还是不行，那...没有那了，最后编译器大喊一声：汝欺我甚，不干了！"}]}]}]},{"ID":"20251025105355-eyl1lc3","Type":"NodeParagraph","Properties":{"id":"20251025105355-eyl1lc3","updated":"20251025110115"},"Children":[{"Type":"NodeText","Data":"例子"}]},{"ID":"20251025110116-ysth1rb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025110116-ysth1rb","updated":"20251025110121"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let array: Rc\u003cBox\u003c[T; 3]\u003e\u003e = ...;\nlet first_entry = array[0];\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025110206-nd84p1h","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251025110206-nd84p1h","updated":"20251025110206"},"Children":[{"ID":"20251025110206-1bj9l23","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251025110206-1bj9l23","updated":"20251025110206"},"Children":[{"ID":"20251025110206-9s8o1rq","Type":"NodeParagraph","Properties":{"id":"20251025110206-9s8o1rq","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"首先， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array[0]"},{"Type":"NodeText","Data":"​ 只是"},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://doc.rust-lang.org/std/ops/trait.Index.html","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​特征的语法糖：编译器会将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array[0]"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array.index(0)"},{"Type":"NodeText","Data":"​ 调用，当然在调用之前，编译器会先检查 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array"},{"Type":"NodeText","Data":"​ 是否实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征。"}]}]},{"ID":"20251025110206-ghxwyht","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251025110206-ghxwyht","updated":"20251025110206"},"Children":[{"ID":"20251025110206-ktsjek5","Type":"NodeParagraph","Properties":{"id":"20251025110206-ktsjek5","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"接着，编译器检查 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 是否有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，结果是否，不仅如此，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 与 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 也没有实现。"}]}]},{"ID":"20251025110206-f4cxbnd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251025110206-f4cxbnd","updated":"20251025110206"},"Children":[{"ID":"20251025110206-qyy40sf","Type":"NodeParagraph","Properties":{"id":"20251025110206-qyy40sf","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"上面的都不能工作，编译器开始对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 进行解引用，把它转变成 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025110206-b0nslsl","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20251025110206-b0nslsl","updated":"20251025110206"},"Children":[{"ID":"20251025110206-ugdzyns","Type":"NodeParagraph","Properties":{"id":"20251025110206-ugdzyns","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"此时继续对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 进行上面的操作 ："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​，和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 都没有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，所以编译器开始对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 进行解引用，然后我们得到了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025110206-s0812te","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20251025110206-s0812te","updated":"20251025110206"},"Children":[{"ID":"20251025110206-qxvpiw7","Type":"NodeParagraph","Properties":{"id":"20251025110206-qxvpiw7","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​ 以及它的各种引用都没有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 索引(是不是很反直觉:D，在直觉中，数组都可以通过索引访问，实际上只有数组切片才可以!)，它也不能再进行解引用，因此编译器只能祭出最后的大杀器：将定长转为不定长，因此 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​ 被转换成 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T]"},{"Type":"NodeText","Data":"​，也就是数组切片，它实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，因此最终我们可以通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​ 方法访问到对应的元素。"}]}]}]},{"ID":"20251025110207-otai97x","Type":"NodeParagraph","Properties":{"id":"20251025110207-otai97x","updated":"20251025110207"}}]}