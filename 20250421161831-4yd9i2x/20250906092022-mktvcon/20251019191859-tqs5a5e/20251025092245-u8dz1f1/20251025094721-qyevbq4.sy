{"ID":"20251025094721-qyevbq4","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251025094721-qyevbq4","title":"类型转换","type":"doc","updated":"20251026122804"},"Children":[{"ID":"20251025094732-vtw3z8g","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025094732-vtw3z8g","updated":"20251025095949"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#as%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"as"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#as%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"转换"}]},{"ID":"20251025094732-pvhz1rv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025094732-pvhz1rv","updated":"20251025095949"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let a = i8::MAX; let a = i32::MAX; //type max value\n   let a = 3.1 as i8;\n   let b = 100_i8 as i32;\n   let c = 'a' as u8; // 将字符'a'转换为整数，97\n内存地址转换为指针\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize; // 将p1内存地址转换为一个整数\nlet second_address = first_address + 4; // 4 == std::mem::size_of::\u003ci32\u003e()，i32类型占用4个字节，因此将内存地址 + 4\nlet p2 = second_address as *mut i32; // 访问该地址指向的下一个整数p2\nunsafe {\n\t//这里提供一个不安全的指针修改\n\t//let p2 = p1.add(1); 避免地址整数地址直接的转换\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);\n转换不具有传递性 就算 e as U1 as U2 是合法的，也不能说明 e as U2 是合法的（e 不能直接转换成 U2）\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025095320-9350931","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025095320-9350931","updated":"20251025100943"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#tryinto-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"TryInto"}]},{"ID":"20251025095321-7buwf74","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025095321-7buwf74","updated":"20251025100941"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::convert::TryInto; //可以去掉，这个特征在prelude里面\nfn main() {\n    let b: i16 = 1500;\n\n    let b_: u8 = match b.try_into() {  //尝试转化为u8，但是值溢出了，会报错，这里可以使用unwrap，提取值，错误就panic\n        Ok(b1) =\u003e b1,\n        Err(e) =\u003e {\n            println!(\"{:?}\", e.to_string());\n            0\n        }\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025101005-bsh8fvm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251025101005-bsh8fvm","updated":"20251026013547"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"通用类型转换"}]},{"ID":"20251025101005-0y9s9h2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025101005-0y9s9h2","updated":"20251025104924"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"强制类型转换\n隐式的，比如参数是不可变借用，但是传入可变借用，会自动降级，等等\n// 1) Deref coercion：\u0026String → \u0026str\nfn takes_str(s: \u0026str) {}\nlet s = String::from(\"hi\");\ntakes_str(\u0026s); // 自动从 \u0026String 转为 \u0026str\n\n// 2) 借用降级：\u0026mut T → \u0026T\nfn takes_ref(x: \u0026i32) {}\nlet mut m = 1;\ntakes_ref(\u0026mut m); // 自动从 \u0026mut i32 转为 \u0026i32\n\n// 3) Unsizing：\u0026[T; N] → \u0026[T]（定长数组到切片）\nfn sum(slice: \u0026[i32]) -\u003e i32 { slice.iter().sum() }\nlet arr = [1, 2, 3];\nlet _ = sum(\u0026arr); // \u0026 [i32; 3] 自动变为 \u0026 [i32]\n\n// 4) 非捕获闭包 → 函数指针 fn(...)\nlet f: fn(i32) -\u003e i32 = |x| x + 1; // 自动从闭包到 fn 指针\nlet _ = f(3);\n\n// 5) 引用 → 原始指针\nlet x = 10;\nlet p_const: *const i32 = \u0026x;      // \u0026T → *const T\nlet mut y = 20;\nlet p_mut: *mut i32 = \u0026mut y;      // \u0026mut T → *mut T\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025105010-llw58ac","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251025105010-llw58ac","updated":"20251026013547"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/converse.html#%E7%82%B9%E6%93%8D%E4%BD%9C%E7%AC%A6","TextMarkTextContent":"点操作符"}]},{"ID":"20251025105011-fct0z60","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025105011-fct0z60","linewrap":"true","updated":"20251025105402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"假设有一个方法 foo，它有一个接收器(接收器就是 self、\u0026self、\u0026mut self 参数)。如果调用 value.foo()，编译器在调用 foo 之前，需要决定到底使用哪个 Self 类型来调用。现在假设 value 拥有类型 T\t\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025105418-yzsb2er","Type":"NodeParagraph","Properties":{"id":"20251025105418-yzsb2er","updated":"20251025105436"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"完全限定语法"},{"Type":"NodeText","Data":"来进行准确的函数调用:"}]},{"ID":"20251025105353-w7ezgve","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251025105353-w7ezgve","updated":"20251025105353"},"Children":[{"ID":"20251025105353-mnd7lf5","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251025105353-mnd7lf5","updated":"20251025105353"},"Children":[{"ID":"20251025105353-n86liil","Type":"NodeParagraph","Properties":{"id":"20251025105353-n86liil","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"首先，编译器检查它是否可以直接调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T::foo(value)"},{"Type":"NodeText","Data":"​，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"值方法调用"}]}]},{"ID":"20251025105353-5iy1wnf","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251025105353-5iy1wnf","updated":"20251025105353"},"Children":[{"ID":"20251025105353-vmjqqwe","Type":"NodeParagraph","Properties":{"id":"20251025105353-vmjqqwe","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"如果上一步调用无法完成(例如方法类型错误或者特征没有针对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Self"},{"Type":"NodeText","Data":"​ 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，例如会尝试以下调用： "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026amp;T\u0026gt;::foo(value)"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;\u0026amp;mut T\u0026gt;::foo(value)"},{"Type":"NodeText","Data":"​，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"引用方法调用"}]}]},{"ID":"20251025105353-6zultuw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251025105353-6zultuw","updated":"20251025105353"},"Children":[{"ID":"20251025105353-pg6hdms","Type":"NodeParagraph","Properties":{"id":"20251025105353-pg6hdms","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若上面两个方法依然不工作，编译器会试着解引用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ ，然后再进行尝试。这里使用了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征 —— 若 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T: Deref\u0026lt;Target = U\u0026gt;"},{"Type":"NodeText","Data":"​ ("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 可以被解引用为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"U"},{"Type":"NodeText","Data":"​)，那么编译器会使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"U"},{"Type":"NodeText","Data":"​ 类型进行尝试，称之为"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"解引用方法调用"}]}]},{"ID":"20251025105353-yqxb5er","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20251025105353-yqxb5er","updated":"20251025105353"},"Children":[{"ID":"20251025105353-060t8vx","Type":"NodeParagraph","Properties":{"id":"20251025105353-060t8vx","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 不能被解引用，且 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 是一个定长类型(在编译期类型长度是已知的)，那么编译器也会尝试将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 从定长类型转为不定长类型，例如将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[i32; 2]"},{"Type":"NodeText","Data":"​ 转为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[i32]"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025105353-m1kke7w","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20251025105353-m1kke7w","updated":"20251025105353"},"Children":[{"ID":"20251025105353-nausrhp","Type":"NodeParagraph","Properties":{"id":"20251025105353-nausrhp","updated":"20251025105353"},"Children":[{"Type":"NodeText","Data":"若还是不行，那...没有那了，最后编译器大喊一声：汝欺我甚，不干了！"}]}]}]},{"ID":"20251025105355-eyl1lc3","Type":"NodeParagraph","Properties":{"id":"20251025105355-eyl1lc3","updated":"20251025110115"},"Children":[{"Type":"NodeText","Data":"例子"}]},{"ID":"20251025110116-ysth1rb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251025110116-ysth1rb","updated":"20251025110121"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"let array: Rc\u003cBox\u003c[T; 3]\u003e\u003e = ...;\nlet first_entry = array[0];\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251025110206-nd84p1h","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251025110206-nd84p1h","updated":"20251025110206"},"Children":[{"ID":"20251025110206-1bj9l23","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251025110206-1bj9l23","updated":"20251025110206"},"Children":[{"ID":"20251025110206-9s8o1rq","Type":"NodeParagraph","Properties":{"id":"20251025110206-9s8o1rq","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"首先， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array[0]"},{"Type":"NodeText","Data":"​ 只是"},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://doc.rust-lang.org/std/ops/trait.Index.html","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​特征的语法糖：编译器会将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array[0]"},{"Type":"NodeText","Data":"​ 转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array.index(0)"},{"Type":"NodeText","Data":"​ 调用，当然在调用之前，编译器会先检查 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"array"},{"Type":"NodeText","Data":"​ 是否实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征。"}]}]},{"ID":"20251025110206-ghxwyht","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251025110206-ghxwyht","updated":"20251025110206"},"Children":[{"ID":"20251025110206-ktsjek5","Type":"NodeParagraph","Properties":{"id":"20251025110206-ktsjek5","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"接着，编译器检查 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 是否有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，结果是否，不仅如此，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 与 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 也没有实现。"}]}]},{"ID":"20251025110206-f4cxbnd","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251025110206-f4cxbnd","updated":"20251025110206"},"Children":[{"ID":"20251025110206-qyy40sf","Type":"NodeParagraph","Properties":{"id":"20251025110206-qyy40sf","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"上面的都不能工作，编译器开始对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;Box\u0026lt;[T; 3]\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​ 进行解引用，把它转变成 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025110206-b0nslsl","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20251025110206-b0nslsl","updated":"20251025110206"},"Children":[{"ID":"20251025110206-ugdzyns","Type":"NodeParagraph","Properties":{"id":"20251025110206-ugdzyns","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"此时继续对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 进行上面的操作 ："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​， "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​，和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 都没有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，所以编译器开始对 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;[T; 3]\u0026gt;"},{"Type":"NodeText","Data":"​ 进行解引用，然后我们得到了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251025110206-s0812te","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20251025110206-s0812te","updated":"20251025110206"},"Children":[{"ID":"20251025110206-qxvpiw7","Type":"NodeParagraph","Properties":{"id":"20251025110206-qxvpiw7","updated":"20251025110206"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​ 以及它的各种引用都没有实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 索引(是不是很反直觉:D，在直觉中，数组都可以通过索引访问，实际上只有数组切片才可以!)，它也不能再进行解引用，因此编译器只能祭出最后的大杀器：将定长转为不定长，因此 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T; 3]"},{"Type":"NodeText","Data":"​ 被转换成 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[T]"},{"Type":"NodeText","Data":"​，也就是数组切片，它实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Index"},{"Type":"NodeText","Data":"​ 特征，因此最终我们可以通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"index"},{"Type":"NodeText","Data":"​ 方法访问到对应的元素。"}]}]}]},{"ID":"20251025110207-otai97x","Type":"NodeParagraph","Properties":{"id":"20251025110207-otai97x","updated":"20251026005643"},"Children":[{"Type":"NodeText","Data":"小tips："}]},{"ID":"20251026005644-chlpx4z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251026005644-chlpx4z","updated":"20251026005852"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn do_stuff\u003cT\u003e(value: \u0026T) {\n    let cloned = value.clone();\n} 按照上面所说，*\u0026T找不到clone后，进行增加引用变成\u0026（*\u0026T），这是变成了\u0026T的clone(所有的引用类型都可以被复制，因为其实就是复制一份地址)\ncloned就变成了一个地址\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251026010110-yhd5lak","Type":"NodeParagraph","Properties":{"id":"20251026010110-yhd5lak","updated":"20251026010110"},"Children":[{"Type":"NodeText","Data":"#[derive(Clone)]\nstruct Container\u003cT\u003e(Arc\u003cT\u003e);"}]},{"ID":"20251026013011-utfgpqp","Type":"NodeParagraph","Properties":{"id":"20251026013011-utfgpqp","updated":"20251026013011"},"Children":[{"Type":"NodeText","Data":"|"}]},{"ID":"20251026013012-d581ya5","Type":"NodeParagraph","Properties":{"id":"20251026013012-d581ya5","updated":"20251026013012"},"Children":[{"Type":"NodeText","Data":"|"}]},{"ID":"20251026013012-jj6t26e","Type":"NodeParagraph","Properties":{"id":"20251026013012-jj6t26e","updated":"20251026013013"},"Children":[{"Type":"NodeText","Data":"|"}]},{"ID":"20251026013013-18e79wa","Type":"NodeParagraph","Properties":{"id":"20251026013013-18e79wa","updated":"20251026013014"},"Children":[{"Type":"NodeText","Data":"v"}]},{"ID":"20251026013015-shaqek0","Type":"NodeParagraph","Properties":{"id":"20251026013015-shaqek0","updated":"20251026013015"},"Children":[{"Type":"NodeText","Data":"impl\u003cT\u003e Clone for Container\u003cT\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self(Arc::clone(\u0026self.0))\n    }\n}"}]},{"ID":"20251026013017-x7097lk","Type":"NodeParagraph","Properties":{"id":"20251026013017-x7097lk","updated":"20251026013017"}},{"ID":"20251026010110-1v8cuco","Type":"NodeParagraph","Properties":{"id":"20251026010110-1v8cuco","updated":"20251026010110"},"Children":[{"Type":"NodeText","Data":"fn clone_containers\u003cT\u003e(foo: \u0026Container\u003ci32\u003e, bar: \u0026Container\u003cT\u003e) {\n    let foo_cloned = foo.clone();\n    let bar_cloned = bar.clone();\n}"}]},{"ID":"20251026005853-bjr66sj","Type":"NodeParagraph","Properties":{"id":"20251026005853-bjr66sj","updated":"20251026010028"},"Children":[{"Type":"NodeText","Data":"复习："}]},{"ID":"20251026010028-cr7re3e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251026010028-cr7re3e","linewrap":"true","updated":"20251026010131"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"一个复杂类型能否派生 Clone，需要它内部的所有子类型都能进行 Clone。因此 Container\u003cT\u003e(Arc\u003cT\u003e) 是否实现 Clone 的关键在于 T 类型是否实现了 Clone 特征。\n推断下上面的 foo_cloned 和 bar_cloned 是什么类型？提示: 关键在 Container 的泛型参数，一个是 i32 的具体类型，一个是泛型类型，其中 i32 实现了 Clone，但是 T 并没有。\n后面自己猜\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251026010042-b135qkv","Type":"NodeParagraph","Properties":{"id":"20251026010042-b135qkv","updated":"20251026012421"},"Children":[{"Type":"NodeText","Data":"解释：猜不出来了"}]},{"ID":"20251026012421-ujboih4","Type":"NodeParagraph","Properties":{"id":"20251026012421-ujboih4","updated":"20251026012607"},"Children":[{"Type":"NodeText","Data":"\t这里derive给container引入了clone特征，然后clone时（需要它内部的所有子类型都能进行 Clone），但是Arc恰好不需要T实现clone特征，but，container的clone时又需要检查里面的所有有没有clone特征，T没实现就不通过，退而求其次，clone \u0026container"}]},{"ID":"20251026012836-u3fe8gk","Type":"NodeParagraph","Properties":{"id":"20251026012836-u3fe8gk","updated":"20251026012950"},"Children":[{"Type":"NodeText","Data":"\t更新：上面的有理解问题，#[derive(Clone)]是给所有子选项增加clone特征约束，Arc又允许没有特征约束的特征进入，所以导致没有clone的特征进入了clone，引发无法clone 的问题"}]},{"ID":"20251026012830-jc8icj4","Type":"NodeParagraph","Properties":{"id":"20251026012830-jc8icj4","updated":"20251026013341"},"Children":[{"Type":"NodeText","Data":"二更："}]},{"ID":"20251026013341-h10jpu5","Type":"NodeParagraph","Properties":{"id":"20251026013341-h10jpu5","updated":"20251026013346"},"Children":[{"Type":"NodeText","Data":"去掉了Arc约束："}]},{"ID":"20251026013346-vcn3fa1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251026013346-vcn3fa1","updated":"20251026013400"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"#[derive(Clone)]\nstruct Container\u003cT\u003e(T);\n结果和上面一样\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251026013410-dic23y3","Type":"NodeList","ListData":{},"Properties":{"id":"20251026013410-dic23y3","updated":"20251026013410"},"Children":[{"ID":"20251026013410-dqe0hej","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026013410-dqe0hej","updated":"20251026013410"},"Children":[{"ID":"20251026013410-8v930ft","Type":"NodeParagraph","Properties":{"id":"20251026013410-8v930ft","updated":"20251026013410"},"Children":[{"Type":"NodeText","Data":"✅ derive 都生成了 where T: Clone"}]}]},{"ID":"20251026013410-lii6oih","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026013410-lii6oih","updated":"20251026013410"},"Children":[{"ID":"20251026013410-1iaqmf6","Type":"NodeParagraph","Properties":{"id":"20251026013410-1iaqmf6","updated":"20251026013410"},"Children":[{"Type":"NodeText","Data":"✅ 泛型函数中 T 都没有 Clone 约束"}]}]},{"ID":"20251026013410-w9kds18","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026013410-w9kds18","updated":"20251026013410"},"Children":[{"ID":"20251026013410-1b1yc6p","Type":"NodeParagraph","Properties":{"id":"20251026013410-1b1yc6p","updated":"20251026013410"},"Children":[{"Type":"NodeText","Data":"✅ 编译器都判定 Container"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003c"}]},{"Type":"NodeText","Data":"T"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"\u003e"}]},{"Type":"NodeText","Data":" 无法 Clone"}]}]},{"ID":"20251026013410-jsfad68","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026013410-jsfad68","updated":"20251026013410"},"Children":[{"ID":"20251026013410-4idbbxm","Type":"NodeParagraph","Properties":{"id":"20251026013410-4idbbxm","updated":"20251026013410"},"Children":[{"Type":"NodeText","Data":"✅ 都退而求其次 clone 引用"}]}]}]},{"ID":"20251026013548-2dcrcgh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"fold":"1","id":"20251026013548-2dcrcgh","updated":"20251026122804"},"Children":[{"Type":"NodeText","Data":"约束是\"使用时检查\"，不是\"传入时检查\""}]},{"ID":"20251026013549-9cr8gzr","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026013549-9cr8gzr","updated":"20251026013549"}},{"ID":"20251026013552-zhnxm89","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026013552-zhnxm89","updated":"20251026013552"}},{"ID":"20251026113531-nsozkv5","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026113531-nsozkv5","style":"font-size: 26px;","updated":"20251026113542"},"Children":[{"Type":"NodeText","Data":"深渊："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mem::transmute\u0026lt;T, U\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251026113537-72hfteg","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026113537-72hfteg","updated":"20251026113631"},"Children":[{"Type":"NodeText","Data":"将类型 T 直接转成类型 U：唯一的要求就是，这两个类型占用同样大小的字节数！"}]},{"ID":"20251026113707-ojep4sh","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026113707-ojep4sh","updated":"20251026113707"},"Children":[{"Type":"NodeText","Data":"会导致什么问题："}]},{"ID":"20251026113712-6pqpzqc","Type":"NodeList","ListData":{"Typ":1},"Properties":{"fold":"1","heading-fold":"1","id":"20251026113712-6pqpzqc","updated":"20251026113712"},"Children":[{"ID":"20251026113712-k8jps7e","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251026113712-k8jps7e","updated":"20251026113712"},"Children":[{"ID":"20251026113712-awikjfo","Type":"NodeParagraph","Properties":{"id":"20251026113712-awikjfo","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"首先也是最重要的，转换后创建一个任意类型的实例会造成无法想象的混乱，而且根本无法预测。不要把 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"3"},{"Type":"NodeText","Data":"​ 转换成 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​ 类型，就算你根本不会去使用该 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"bool"},{"Type":"NodeText","Data":"​ 类型，也不要去这样转换"}]}]},{"ID":"20251026113712-ei156ga","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251026113712-ei156ga","updated":"20251026113712"},"Children":[{"ID":"20251026113712-jam28mi","Type":"NodeParagraph","Properties":{"id":"20251026113712-jam28mi","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"变形后会有一个重载的返回类型，即使你没有指定返回类型，为了满足类型推导的需求，依然会产生千奇百怪的类型"}]}]},{"ID":"20251026113712-8eyrtxa","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251026113712-8eyrtxa","updated":"20251026113712"},"Children":[{"ID":"20251026113712-9ir2pr0","Type":"NodeParagraph","Properties":{"id":"20251026113712-9ir2pr0","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;"},{"Type":"NodeText","Data":"​ 变形为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;mut"},{"Type":"NodeText","Data":"​ 是未定义的行为"}]},{"ID":"20251026113712-20svr75","Type":"NodeList","ListData":{},"Properties":{"id":"20251026113712-20svr75","updated":"20251026113712"},"Children":[{"ID":"20251026113712-roizeu4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026113712-roizeu4","updated":"20251026113712"},"Children":[{"ID":"20251026113712-ceb1cpw","Type":"NodeParagraph","Properties":{"id":"20251026113712-ceb1cpw","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"这种转换永远都是未定义的"}]}]},{"ID":"20251026113712-czyh1ky","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026113712-czyh1ky","updated":"20251026113712"},"Children":[{"ID":"20251026113712-i8d7ee0","Type":"NodeParagraph","Properties":{"id":"20251026113712-i8d7ee0","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"不，你不能这么做"}]}]},{"ID":"20251026113712-uzlad3b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026113712-uzlad3b","updated":"20251026113712"},"Children":[{"ID":"20251026113712-hsmrntj","Type":"NodeParagraph","Properties":{"id":"20251026113712-hsmrntj","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"不要多想，你没有那种幸运"}]}]}]}]},{"ID":"20251026113712-2tru2fn","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20251026113712-2tru2fn","updated":"20251026113712"},"Children":[{"ID":"20251026113712-a4txis9","Type":"NodeParagraph","Properties":{"id":"20251026113712-a4txis9","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"变形为一个未指定生命周期的引用会导致"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/lifetime/advance.html","TextMarkTextContent":"无界生命周期"}]}]},{"ID":"20251026113712-ewc6j9b","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20251026113712-ewc6j9b","updated":"20251026113712"},"Children":[{"ID":"20251026113712-c5wqogc","Type":"NodeParagraph","Properties":{"id":"20251026113712-c5wqogc","updated":"20251026113712"},"Children":[{"Type":"NodeText","Data":"在复合类型之间互相变换时，你需要保证它们的排列布局是一模一样的！一旦不一样，那么字段就会得到不可预期的值，这也是未定义的行为，至于你会不会因此愤怒， "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"WHO CARES"},{"Type":"NodeText","Data":" ，你都用了变形了，老兄！"}]}]}]},{"ID":"20251026120607-re84xjo","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026120607-re84xjo","style":"font-size: 26px;","updated":"20251026122442"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"mem::transmute_copy\u0026lt;T, U\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251026122451-huocgeh","Type":"NodeParagraph","Properties":{"fold":"1","heading-fold":"1","id":"20251026122451-huocgeh","updated":"20251026122501"},"Children":[{"Type":"NodeText","Data":"它从 T 类型中拷贝出 U 类型所需的字节数，然后转换成 U。 mem::transmute 尚有大小检查，能保证两个数据的内存大小一致，现在这哥们干脆连这个也丢了，只不过 U 的尺寸若是比 T 大，会是一个未定义行为"}]},{"ID":"20251026122517-bot8vk4","Type":"NodeList","ListData":{},"Properties":{"fold":"1","heading-fold":"1","id":"20251026122517-bot8vk4","updated":"20251026122530"},"Children":[{"ID":"20251026122517-obgel8c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026122517-obgel8c","updated":"20251026122517"},"Children":[{"ID":"20251026122517-rcr8dx1","Type":"NodeParagraph","Properties":{"id":"20251026122517-rcr8dx1","updated":"20251026122517"},"Children":[{"Type":"NodeText","Data":"将裸指针变成函数指针："}]}]},{"ID":"20251026122519-69eant6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026122519-69eant6","updated":"20251026122530"},"Children":[{"ID":"20251026122519-neqka6e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251026122519-neqka6e","updated":"20251026122530"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn foo() -\u003e i32 {\n    0\n}\n\nlet pointer = foo as *const ();\nlet function = unsafe { \n    // 将裸指针转换为函数指针\n    std::mem::transmute::\u003c*const (), fn() -\u003e i32\u003e(pointer) \n};\nassert_eq!(function(), 0);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20251026122534-3qbyddq","Type":"NodeList","ListData":{},"Properties":{"fold":"1","heading-fold":"1","id":"20251026122534-3qbyddq","updated":"20251026122804"},"Children":[{"ID":"20251026122534-0s4eznc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026122534-0s4eznc","updated":"20251026122534"},"Children":[{"ID":"20251026122534-9jiekd1","Type":"NodeParagraph","Properties":{"id":"20251026122534-9jiekd1","updated":"20251026122534"},"Children":[{"Type":"NodeText","Data":"延长生命周期，或者缩短一个静态生命周期寿命："}]}]},{"ID":"20251026122535-5yqc41u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251026122535-5yqc41u","updated":"20251026122804"},"Children":[{"ID":"20251026122535-p962nlt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251026122535-p962nlt","updated":"20251026122804"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"struct R\u003c'a\u003e(\u0026'a i32);\n// 不安全\n// 将 'b 生命周期延长至 'static 生命周期   ， 可能有全局变量编译器通不过，然后转换一下生命周期\nunsafe fn extend_lifetime\u003c'b\u003e(r: R\u003c'b\u003e) -\u003e R\u003c'static\u003e {\n    std::mem::transmute::\u003cR\u003c'b\u003e, R\u003c'static\u003e\u003e(r)\n}\n\n// 将 'static 生命周期缩短至 'c 生命周期   ，  API 需要特定生命周期，适配一下\nunsafe fn shorten_invariant_lifetime\u003c'b, 'c\u003e(r: \u0026'b mut R\u003c'static\u003e) -\u003e \u0026'b mut R\u003c'c\u003e {\n    std::mem::transmute::\u003c\u0026'b mut R\u003c'static\u003e, \u0026'b mut R\u003c'c\u003e\u003e(r)\n}\n// 缩短生命周期：'static -\u003e 'short\n// \n// 'static 的数据确实能在 'short 期间存活\n// 不会出现悬垂引用\n// \n// 只是类型系统因为不变性而阻止\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]}]}