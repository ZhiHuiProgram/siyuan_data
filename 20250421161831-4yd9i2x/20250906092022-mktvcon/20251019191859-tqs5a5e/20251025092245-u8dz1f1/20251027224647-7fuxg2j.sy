{"ID":"20251027224647-7fuxg2j","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251027224647-7fuxg2j","title":"枚举和整数","type":"doc","updated":"20251027232017"},"Children":[{"ID":"20251027224656-xi5o6xs","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20251027224656-xi5o6xs","updated":"20251027230556"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/enum-int.html#%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%9A%E4%B8%BE","TextMarkTextContent":"整数转换为枚举"}]},{"ID":"20251027224657-i4658zj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251027224657-i4658zj","updated":"20251027224704"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"在 Rust 中，从枚举到整数的转换很容易，但是反过来，就没那么容易，甚至部分实现还挺邪恶, 例如使用transmute。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251027224704-3d7c1l5","Type":"NodeParagraph","Properties":{"id":"20251027224704-3d7c1l5","updated":"20251027225159"},"Children":[{"Type":"NodeText","Data":"let x = MyEnum::C as i32;  √ 可以"}]},{"ID":"20251027225200-ouet0o0","Type":"NodeParagraph","Properties":{"id":"20251027225200-ouet0o0","updated":"20251027225206"},"Children":[{"Type":"NodeText","Data":"反之不行"}]},{"ID":"20251027225543-zf8fd9e","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251027225543-zf8fd9e","updated":"20251027230556"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/enum-int.html#%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E5%BA%93","TextMarkTextContent":"使用三方库"}]},{"ID":"20251027225545-csvxel3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251027225545-csvxel3","updated":"20251027230556"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"引入\n[dependencies]\nnum-traits = \"0.2.14\"\nnum-derive = \"0.3.3\"\n\nuse num_derive::FromPrimitive;\nuse num_traits::FromPrimitive;\n\n#[derive(FromPrimitive)]\nenum MyEnum {\n    A = 1,\n    B,\n    C,\n}\n\nfn main() {\n    let x = 2;\n\n    match FromPrimitive::from_i32(x) {  //本身不知道什么类型，但是match里面可以推断\n        Some(MyEnum::A) =\u003e println!(\"Got A\"),\n        Some(MyEnum::B) =\u003e println!(\"Got B\"),\n        Some(MyEnum::C) =\u003e println!(\"Got C\"),\n        None            =\u003e println!(\"Couldn't convert {}\", x),\n    }\n}\n除了上面的库，还可以使用一个较新的库: num_enums。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251027230601-nvq17de","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251027230601-nvq17de","updated":"20251027232017"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/enum-int.html#tryfrom--%E5%AE%8F","TextMarkTextContent":"TryFrom + 宏"},{"Type":"NodeText","Data":" ：有很多方法可以使用，"}]},{"ID":"20251027230602-gww4clx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251027230602-gww4clx","updated":"20251027231342"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::convert::TryFrom;\n\nimpl TryFrom\u003ci32\u003e for MyEnum {\n    type Error = ();\n\n    fn try_from(v: i32) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match v {\n            x if x == MyEnum::A as i32 =\u003e Ok(MyEnum::A),\n            x if x == MyEnum::B as i32 =\u003e Ok(MyEnum::B),\n            x if x == MyEnum::C as i32 =\u003e Ok(MyEnum::C),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\nuse std::convert::TryInto;\n\nfn main() {\n    let x = MyEnum::C as i32;\n\n    match x.try_into() {\n        Ok(MyEnum::A) =\u003e println!(\"a\"),\n        Ok(MyEnum::B) =\u003e println!(\"b\"),\n        Ok(MyEnum::C) =\u003e println!(\"c\"),\n        Err(_) =\u003e eprintln!(\"unknown number\"),\n    }\n}\n\n\nuse std::convert::TryFrom;\n\nimpl TryFrom\u003ci32\u003e for MyEnum {\n    type Error = ();\n    \n    fn try_from(v: i32) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match v {\n            1 =\u003e Ok(MyEnum::A),\n            2 =\u003e Ok(MyEnum::B),\n            3 =\u003e Ok(MyEnum::C),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n// 使用：方式更多\nlet e1 = MyEnum::try_from(2)?;       // ✅ 显式\nlet e2: MyEnum = 2.try_into()?;      // ✅ 自动反向调用\nlet e3 = \u003cMyEnum\u003e::try_from(2)?;     // ✅ 完全限定\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251027231420-5vctcg0","Type":"NodeParagraph","Properties":{"id":"20251027231420-5vctcg0","updated":"20251027232017"},"Children":[{"Type":"NodeText","Data":"宏：通用宏，一个宏可以用在所有枚举，不需要每个类型都实现一遍"}]},{"ID":"20251027231430-q6yw6na","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251027231430-q6yw6na","updated":"20251027231437"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"#[macro_export]\nmacro_rules! back_to_enum {\n    ($(#[$meta:meta])* $vis:vis enum $name:ident {\n        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*\n    }) =\u003e {\n        $(#[$meta])*\n        $vis enum $name {\n            $($(#[$vmeta])* $vname $(= $val)?,)*\n        }\n\n        impl std::convert::TryFrom\u003ci32\u003e for $name {\n            type Error = ();\n\n            fn try_from(v: i32) -\u003e Result\u003cSelf, Self::Error\u003e {\n                match v {\n                    $(x if x == $name::$vname as i32 =\u003e Ok($name::$vname),)*\n                    _ =\u003e Err(()),\n                }\n            }\n        }\n    }\n}\n\nback_to_enum! {\n    enum MyEnum {\n        A = 1,\n        B,\n        C,\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251027231442-h204j2q","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251027231442-h204j2q","updated":"20251027231817"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/into-types/enum-int.html#%E9%82%AA%E6%81%B6%E4%B9%8B%E7%8E%8B-stdmemtransmute","TextMarkTextContent":"邪恶之王 std::mem::transmute"}]},{"ID":"20251027231803-lt4tf69","Type":"NodeParagraph","Properties":{"id":"20251027231803-lt4tf69","updated":"20251027231817"},"Children":[{"Type":"NodeText","Data":"数值一定不会超过枚举，如果超过，则有不可预测的错误"}]},{"ID":"20251027231540-oe9jn1v","Type":"NodeParagraph","Properties":{"id":"20251027231540-oe9jn1v","updated":"20251027231540"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这个方法原则上并不推荐，但是有其存在的意义，如果要使用，你需要清晰的知道自己为什么使用"},{"Type":"NodeText","Data":"。"}]},{"ID":"20251027231549-r6wky0f","Type":"NodeParagraph","Properties":{"id":"20251027231549-r6wky0f","updated":"20251027231549"},"Children":[{"Type":"NodeText","Data":"最好使用#[repr(..)]来控制底层类型的大小，免得本来需要 i32，结果传入 i64，最终内存无法对齐，产生奇怪的结果"}]},{"ID":"20251027231443-79bj0iz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251027231443-79bj0iz","updated":"20251027231544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"#[repr(i32)]\nenum MyEnum {\n    A = 1, B, C\n}\n\nfn main() {\n    let x = MyEnum::C;\n    let y = x as i32;\n    let z: MyEnum = unsafe { std::mem::transmute(y) };\n\n    // match the enum that came from an int\n    match z {\n        MyEnum::A =\u003e { println!(\"Found A\"); }\n        MyEnum::B =\u003e { println!(\"Found B\"); }\n        MyEnum::C =\u003e { println!(\"Found C\"); }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}