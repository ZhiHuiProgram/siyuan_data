{"ID":"20251028223203-90idmau","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251028223203-90idmau","title":"Deref 解引用","type":"doc","updated":"20251029230943"},"Children":[{"ID":"20251028223948-lcfb2gj","Type":"NodeParagraph","Properties":{"id":"20251028223948-lcfb2gj","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"何为智能指针？能不让你写出 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"****s"},{"Type":"NodeText","Data":"​ 形式的解引用，我认为就是智能: )，智能指针的名称来源，主要就在于它实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 特征，这两个特征可以智能地帮助我们节省使用上的负担："}]},{"ID":"20251028223948-m927mt3","Type":"NodeList","ListData":{},"Properties":{"id":"20251028223948-m927mt3","updated":"20251028223948"},"Children":[{"ID":"20251028223948-ic9gmhb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028223948-ic9gmhb","updated":"20251028223948"},"Children":[{"ID":"20251028223948-hi68ygi","Type":"NodeParagraph","Properties":{"id":"20251028223948-hi68ygi","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251028223948-2af6qu2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028223948-2af6qu2","updated":"20251028223948"},"Children":[{"ID":"20251028223948-17xflfo","Type":"NodeParagraph","Properties":{"id":"20251028223948-17xflfo","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作"}]}]}]},{"ID":"20251028223948-q1bqiil","Type":"NodeParagraph","Properties":{"id":"20251028223948-q1bqiil","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"先来看看 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征是如何工作的。"}]},{"ID":"20251028223949-nkq46pt","Type":"NodeParagraph","Properties":{"id":"20251028223949-nkq46pt","updated":"20251028224059"},"Children":[{"Type":"NodeText","Data":"常规的解引用："}]},{"ID":"20251028224059-ll16z7r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028224059-ll16z7r","updated":"20251028224102"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let x = 5;\n    let y = \u0026x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028224110-e6ygegk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028224110-e6ygegk","updated":"20251028230016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8","TextMarkTextContent":"智能指针解引用"}]},{"ID":"20251028224110-wn5nsfz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028224110-wn5nsfz","updated":"20251028224756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"实现 Deref 后的智能指针结构体，就可以像普通引用一样，通过 * 进行解引用，例如 Box\u003cT\u003e 智能指针：\nfn main() {\n    let x = Box::new(1);\n    let sum = *x + 1;\n}\n智能指针 x 被 * 解引用为 i32 类型的值 1，然后再进行求和。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028224801-u1yvoue","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028224801-u1yvoue","updated":"20251028230016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88","TextMarkTextContent":"定义自己的智能指针"},{"Type":"NodeText","Data":" :返回剥皮的引用"}]},{"ID":"20251028225259-o2augn7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028225259-o2augn7","updated":"20251028225304"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::ops::Deref;\n\nstruct MyBox\u003cT\u003e(T);\n\nimpl \u003cT\u003e Deref for MyBox\u003cT\u003e {\n    type Target = T;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nfn main(){\n    let testbox = MyBox(String::from(\"string\"));\n    println!(\"{:?}\", *testbox);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028225838-clm896k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028225838-clm896k","updated":"20251028230007"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#-%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86","TextMarkTextContent":"*"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#-%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86","TextMarkTextContent":" 背后的原理"}]},{"ID":"20251028225838-3oum8yv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028225838-3oum8yv","updated":"20251028225923"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当我们对智能指针 Box 进行解引用时，实际上 Rust 为我们调用了以下方法：\n*(y.deref())\n\n* 不会无限递归替换，从 *y 到 *(y.deref()) 只会发生一次，而不会继续进行替换然后产生形如 *((y.deref()).deref()) 的怪物\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028230023-kz4t95v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028230023-kz4t95v","updated":"20251029224219"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F-deref-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"函数和方法中的隐式 Deref 转换"}]},{"ID":"20251028230024-bqjj2q1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028230024-bqjj2q1","updated":"20251029223056"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"若一个类型实现了 Deref 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 Deref 转换\nfn main() {\n    let s = String::from(\"hello world\");\n    display(\u0026s)\n}\n\nfn display(s: \u0026str) {\n    println!(\"{}\",s);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251029223112-skne8dc","Type":"NodeList","ListData":{},"Properties":{"id":"20251029223112-skne8dc","updated":"20251029223112"},"Children":[{"ID":"20251029223112-xp2xz1v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251029223112-xp2xz1v","updated":"20251029223112"},"Children":[{"ID":"20251029223112-t0kdq67","Type":"NodeParagraph","Properties":{"id":"20251029223112-t0kdq67","updated":"20251029223112"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":"​ 实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征，可以在需要时自动被转换为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;str"},{"Type":"NodeText","Data":"​ 类型"}]}]},{"ID":"20251029223112-s3qz688","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251029223112-s3qz688","updated":"20251029223112"},"Children":[{"ID":"20251029223112-h3isff4","Type":"NodeParagraph","Properties":{"id":"20251029223112-h3isff4","updated":"20251029223112"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;s"},{"Type":"NodeText","Data":"​ 是一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;String"},{"Type":"NodeText","Data":"​ 类型，当它被传给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"display"},{"Type":"NodeText","Data":"​ 函数时，自动通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 转换成了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;str"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251029223112-4t91xb7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251029223112-4t91xb7","updated":"20251029223112"},"Children":[{"ID":"20251029223112-dzr69d9","Type":"NodeParagraph","Properties":{"id":"20251029223112-dzr69d9","updated":"20251029223112"},"Children":[{"Type":"NodeText","Data":"必须使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;s"},{"Type":"NodeText","Data":"​ 的方式来触发 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​(仅引用类型的实参才会触发自动解引用)"}]}]}]},{"ID":"20251029223440-19j8k83","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251029223440-19j8k83","updated":"20251029224219"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%9A%90%E5%BC%8F-deref-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"连续的隐式 Deref 转换"}]},{"ID":"20251029223441-kop5ory","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251029223441-kop5ory","updated":"20251029223544"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let s = MyBox::new(String::from(\"hello world\"));\n    display(\u0026s)\n}\n\nfn display(s: \u0026str) {   //mybox deref成了string，没找到\u0026str，继续deref，找到了\n    println!(\"{}\",s);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251029223447-364mbdw","Type":"NodeParagraph","Properties":{"id":"20251029223447-364mbdw","updated":"20251029223722"},"Children":[{"Type":"NodeText","Data":"Rust 故意设计了这个特性，就是为了让代码更简洁。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"可以接受更多类型"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251029224219-0902i8v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251029224219-0902i8v","updated":"20251029225058"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#deref-%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93","TextMarkTextContent":"Deref 规则总结"}]},{"ID":"20251029224220-wp6koss","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251029224220-wp6koss","updated":"20251029224621"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"Rust 会在解引用时自动把智能指针和 \u0026\u0026\u0026\u0026v 做引用归一化操作，转换成 \u0026v 形式，最终再对 \u0026v 进行解引用\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251029225058-of9rxw4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251029225058-of9rxw4","updated":"20251029230023"},"Children":[{"Type":"NodeText","Data":"✅ 会触发 Deref 的情况"}]},{"ID":"20251029225058-sjelyvh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20251029225058-sjelyvh","updated":"20251029230023"},"Children":[{"Type":"NodeText","Data":"条件（需同时满足）"}]},{"ID":"20251029225058-rd7z2sr","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20251029225058-rd7z2sr","updated":"20251029225058"},"Children":[{"ID":"20251029225058-q1gyjbg","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20251029225058-q1gyjbg","updated":"20251029225058"},"Children":[{"ID":"20251029225058-8uxeniy","Type":"NodeParagraph","Properties":{"id":"20251029225058-8uxeniy","updated":"20251029225058"},"Children":[{"Type":"NodeText","Data":"✅ 类型实现了 Deref trait"}]}]},{"ID":"20251029225058-d0g0li6","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20251029225058-d0g0li6","updated":"20251029225058"},"Children":[{"ID":"20251029225058-nor8zrr","Type":"NodeParagraph","Properties":{"id":"20251029225058-nor8zrr","updated":"20251029225058"},"Children":[{"Type":"NodeText","Data":"✅ 有明确的目标类型（需要转换到什么类型）"}]}]},{"ID":"20251029225058-m6kng42","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20251029225058-m6kng42","updated":"20251029225058"},"Children":[{"ID":"20251029225058-s6bssqv","Type":"NodeParagraph","Properties":{"id":"20251029225058-s6bssqv","updated":"20251029225058"},"Children":[{"Type":"NodeText","Data":"✅ 类型不匹配（当前类型 ≠ 目标类型）"}]}]}]},{"ID":"20251029230022-xopl299","Type":"NodeList","ListData":{},"Properties":{"id":"20251029230022-xopl299","updated":"20251029230022"},"Children":[{"ID":"20251029230022-ao7q9vo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251029230022-ao7q9vo","updated":"20251029230022"},"Children":[{"ID":"20251029230022-highjom","Type":"NodeParagraph","Properties":{"id":"20251029230022-highjom","updated":"20251029230022"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原生引用（"},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"\u0026amp;T"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"）"},{"Type":"NodeText","Data":" 的嵌套（如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;\u0026amp;T"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026amp;\u0026amp;\u0026amp;T"},{"Type":"NodeText","Data":"​），编译器会自动解引用，无需 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征。"}]}]},{"ID":"20251029230022-imal76l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251029230022-imal76l","updated":"20251029230022"},"Children":[{"ID":"20251029230022-hbhvcbo","Type":"NodeParagraph","Properties":{"id":"20251029230022-hbhvcbo","updated":"20251029230022"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"自定义类型"},{"Type":"NodeText","Data":" 的嵌套（如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"MyBox\u0026lt;MyBox\u0026lt;T\u0026gt;\u0026gt;"},{"Type":"NodeText","Data":"​），必须实现 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 才能自动解引用。"}]}]}]},{"ID":"20251029230143-ypbak54","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251029230143-ypbak54","updated":"20251029230943"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E4%B8%89%E7%A7%8D-deref-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"三种 Deref 转换"}]},{"ID":"20251029230144-903wyop","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251029230144-903wyop","linewrap":"true","updated":"20251029230943"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当 T: Deref\u003cTarget=U\u003e，可以将 \u0026T 转换成 \u0026U，也就是我们之前看到的例子\n当 T: DerefMut\u003cTarget=U\u003e，可以将 \u0026mut T 转换成 \u0026mut U\n当 T: Deref\u003cTarget=U\u003e，可以将 \u0026mut T 转换成 \u0026U\n\nstruct MyBox\u003cT\u003e {\n    v: T,\n}\n\nimpl\u003cT\u003e MyBox\u003cT\u003e {\n    fn new(x: T) -\u003e MyBox\u003cT\u003e {\n        MyBox { v: x }\n    }\n}\n\nuse std::ops::Deref;\n\nimpl\u003cT\u003e Deref for MyBox\u003cT\u003e {\n    type Target = T;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.v\n    }\n}\n\nuse std::ops::DerefMut;\n\nimpl\u003cT\u003e DerefMut for MyBox\u003cT\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.v\n    }\n}\n\nfn main() {\n    let mut s = MyBox::new(String::from(\"hello, \"));\n    display(\u0026mut s)\n}\n\nfn display(s: \u0026mut String) {\n    s.push_str(\"world\");\n    println!(\"{}\", s);\n}\n\n\n第三种方法：  没啥区别，只是会把可变引用传入，变成不可变引用\nimpl\u003cT\u003e Deref for MyBox\u003cT\u003e {\n    type Target = T;\n\n    fn deref(\u0026 self) -\u003e \u0026Self::Target {\n        \u0026self.v\n    }\n}\n\nfn main() {\n    let mut s = MyBox::new(String::from(\"hello, \"));\n    display(\u0026mut s)\n}\n\nfn display(s: \u0026 String) {\n    println!(\"{}\", s);\n}\n\n\n要实现 DerefMut 必须要先实现 Deref 特征：pub trait DerefMut: Deref\nT: DerefMut\u003cTarget=U\u003e 解读：将 \u0026mut T 类型通过 DerefMut 特征的方法转换为 \u0026mut U 类型，对应上例中，就是将 \u0026mut MyBox\u003cString\u003e 转换为 \u0026mut String\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251029230149-9rus2lc","Type":"NodeParagraph","Properties":{"id":"20251029230149-9rus2lc","updated":"20251029230459"},"Children":[{"Type":"NodeText","Data":"我们也可以为自己的类型实现 Deref 特征，但是原则上来说，只应该为自定义的智能指针实现 Deref。例如，虽然你可以为自己的自定义数组类型实现 Deref 以避免 myArr.0[0] 的使用形式，但是 Rust 官方并不推荐这么做，特别是在你开发三方库时"}]}]}