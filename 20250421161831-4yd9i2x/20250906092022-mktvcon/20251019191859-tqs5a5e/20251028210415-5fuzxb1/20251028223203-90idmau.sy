{"ID":"20251028223203-90idmau","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251028223203-90idmau","title":"Deref 解引用","type":"doc","updated":"20251028230217"},"Children":[{"ID":"20251028223948-lcfb2gj","Type":"NodeParagraph","Properties":{"id":"20251028223948-lcfb2gj","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"何为智能指针？能不让你写出 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"****s"},{"Type":"NodeText","Data":"​ 形式的解引用，我认为就是智能: )，智能指针的名称来源，主要就在于它实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 特征，这两个特征可以智能地帮助我们节省使用上的负担："}]},{"ID":"20251028223948-m927mt3","Type":"NodeList","ListData":{},"Properties":{"id":"20251028223948-m927mt3","updated":"20251028223948"},"Children":[{"ID":"20251028223948-ic9gmhb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028223948-ic9gmhb","updated":"20251028223948"},"Children":[{"ID":"20251028223948-hi68ygi","Type":"NodeParagraph","Properties":{"id":"20251028223948-hi68ygi","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*T"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251028223948-2af6qu2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028223948-2af6qu2","updated":"20251028223948"},"Children":[{"ID":"20251028223948-17xflfo","Type":"NodeParagraph","Properties":{"id":"20251028223948-17xflfo","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作"}]}]}]},{"ID":"20251028223948-q1bqiil","Type":"NodeParagraph","Properties":{"id":"20251028223948-q1bqiil","updated":"20251028223948"},"Children":[{"Type":"NodeText","Data":"先来看看 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征是如何工作的。"}]},{"ID":"20251028223949-nkq46pt","Type":"NodeParagraph","Properties":{"id":"20251028223949-nkq46pt","updated":"20251028224059"},"Children":[{"Type":"NodeText","Data":"常规的解引用："}]},{"ID":"20251028224059-ll16z7r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028224059-ll16z7r","updated":"20251028224102"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let x = 5;\n    let y = \u0026x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028224110-e6ygegk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028224110-e6ygegk","updated":"20251028230016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8","TextMarkTextContent":"智能指针解引用"}]},{"ID":"20251028224110-wn5nsfz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028224110-wn5nsfz","updated":"20251028224756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"实现 Deref 后的智能指针结构体，就可以像普通引用一样，通过 * 进行解引用，例如 Box\u003cT\u003e 智能指针：\nfn main() {\n    let x = Box::new(1);\n    let sum = *x + 1;\n}\n智能指针 x 被 * 解引用为 i32 类型的值 1，然后再进行求和。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028224801-u1yvoue","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028224801-u1yvoue","updated":"20251028230016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88","TextMarkTextContent":"定义自己的智能指针"},{"Type":"NodeText","Data":" :返回剥皮的引用"}]},{"ID":"20251028225259-o2augn7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028225259-o2augn7","updated":"20251028225304"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::ops::Deref;\n\nstruct MyBox\u003cT\u003e(T);\n\nimpl \u003cT\u003e Deref for MyBox\u003cT\u003e {\n    type Target = T;\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nfn main(){\n    let testbox = MyBox(String::from(\"string\"));\n    println!(\"{:?}\", *testbox);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028225838-clm896k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028225838-clm896k","updated":"20251028230007"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#-%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86","TextMarkTextContent":"*"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#-%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86","TextMarkTextContent":" 背后的原理"}]},{"ID":"20251028225838-3oum8yv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028225838-3oum8yv","updated":"20251028225923"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"当我们对智能指针 Box 进行解引用时，实际上 Rust 为我们调用了以下方法：\n*(y.deref())\n\n* 不会无限递归替换，从 *y 到 *(y.deref()) 只会发生一次，而不会继续进行替换然后产生形如 *((y.deref()).deref()) 的怪物\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028230023-kz4t95v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028230023-kz4t95v","updated":"20251028230217"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/deref.html#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F-deref-%E8%BD%AC%E6%8D%A2","TextMarkTextContent":"函数和方法中的隐式 Deref 转换"}]},{"ID":"20251028230024-bqjj2q1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028230024-bqjj2q1","updated":"20251028230217"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"1\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}