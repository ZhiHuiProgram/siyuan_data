{"ID":"20251028211614-dpb93bh","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251028211614-dpb93bh","title":"Box\u0026lt;T\u0026gt; 堆对象分配","type":"doc","updated":"20251028222731"},"Children":[{"ID":"20251028212104-0tq1vaq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028212104-0tq1vaq","updated":"20251028213556"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#rust-%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88","TextMarkTextContent":"Rust 中的堆栈"},{"Type":"NodeText","Data":"："}]},{"ID":"20251028212105-8a3urfm","Type":"NodeParagraph","Properties":{"id":"20251028212105-8a3urfm","updated":"20251028212210"},"Children":[{"Type":"NodeText","Data":"一般来说"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"操作系统对栈内存的大小都有限制"},{"Type":"NodeText","Data":"，因此 C 语言中无法创建任意长度的数组"}]},{"ID":"20251028212210-7303c7a","Type":"NodeParagraph","Properties":{"id":"20251028212210-7303c7a","updated":"20251028212211"},"Children":[{"Type":"NodeText","Data":"在 Rust 中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"main"},{"Type":"NodeText","Data":"​ 线程的"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/compiler/pitfalls/stack-overflow.html","TextMarkTextContent":"栈大小是 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/compiler/pitfalls/stack-overflow.html","TextMarkTextContent":"8MB"},{"Type":"NodeText","Data":"​，普通线程是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"2MB"},{"Type":"NodeText","Data":"​，在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。"}]},{"ID":"20251028212211-08faln5","Type":"NodeParagraph","Properties":{"id":"20251028212211-08faln5","updated":"20251028212327"},"Children":[{"Type":"NodeText","Data":"与栈相反，堆上内存则是从低位地址向上增长，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"堆内存通常只受物理内存限制"},{"Type":"NodeText","Data":"，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高。"}]},{"ID":"20251028212327-qvo9y3z","Type":"NodeParagraph","Properties":{"id":"20251028212327-qvo9y3z","updated":"20251028213430"},"Children":[{"Type":"NodeText","Data":"Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）"}]},{"ID":"20251028213459-meo23zx","Type":"NodeParagraph","Properties":{"id":"20251028213459-meo23zx","updated":"20251028213508"},"Children":[{"Type":"NodeText","Data":"所有权转移："}]},{"ID":"20251028213508-mx4lx58","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028213508-mx4lx58","updated":"20251028213511"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let b = foo(\"world\");\n    println!(\"{}\", b);\n}\n\nfn foo(x: \u0026str) -\u003e String {\n    let a = \"Hello, \".to_string() + x;\n    a\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028213555-zsd6qjf","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028213555-zsd6qjf","updated":"20251028213556"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E5%A0%86%E6%A0%88%E7%9A%84%E6%80%A7%E8%83%BD","TextMarkTextContent":"堆栈的性能"}]},{"ID":"20251028213555-byz7hsq","Type":"NodeParagraph","Properties":{"id":"20251028213555-byz7hsq","updated":"20251028213555"},"Children":[{"Type":"NodeText","Data":"很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论："}]},{"ID":"20251028213555-75kwyva","Type":"NodeList","ListData":{},"Properties":{"id":"20251028213555-75kwyva","updated":"20251028213555"},"Children":[{"ID":"20251028213555-8wu5zss","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213555-8wu5zss","updated":"20251028213555"},"Children":[{"ID":"20251028213555-tqge9uk","Type":"NodeParagraph","Properties":{"id":"20251028213555-tqge9uk","updated":"20251028213555"},"Children":[{"Type":"NodeText","Data":"小型数据，在栈上的分配性能和读取性能都要比堆上高"}]}]},{"ID":"20251028213555-6mqvzwg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213555-6mqvzwg","updated":"20251028213555"},"Children":[{"ID":"20251028213555-c8hbs8d","Type":"NodeParagraph","Properties":{"id":"20251028213555-c8hbs8d","updated":"20251028213555"},"Children":[{"Type":"NodeText","Data":"中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址"}]}]},{"ID":"20251028213555-v0amka2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213555-v0amka2","updated":"20251028213555"},"Children":[{"ID":"20251028213555-fo2u6k3","Type":"NodeParagraph","Properties":{"id":"20251028213555-fo2u6k3","updated":"20251028213555"},"Children":[{"Type":"NodeText","Data":"大型数据，只建议在堆上分配和使用"}]}]}]},{"ID":"20251028213555-osw6t9h","Type":"NodeParagraph","Properties":{"id":"20251028213555-osw6t9h","updated":"20251028213555"},"Children":[{"Type":"NodeText","Data":"总之，栈的分配速度肯定比堆上快，但是读取速度往往取决于你的数据能不能放入寄存器或 CPU 高速缓存。 因此不要仅仅因为堆上性能不如栈这个印象，就总是优先选择栈，导致代码更复杂的实现。"}]},{"ID":"20251028213603-m3c2ahs","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028213603-m3c2ahs","updated":"20251028215503"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#box-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF","TextMarkTextContent":"Box 的使用场景"}]},{"ID":"20251028213656-cmh6hg7","Type":"NodeParagraph","Properties":{"id":"20251028213656-cmh6hg7","updated":"20251028213657"},"Children":[{"Type":"NodeText","Data":"由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一"}]},{"ID":"20251028213701-xgf0tcq","Type":"NodeList","ListData":{},"Properties":{"id":"20251028213701-xgf0tcq","updated":"20251028213701"},"Children":[{"ID":"20251028213701-i4pwp3x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213701-i4pwp3x","updated":"20251028213701"},"Children":[{"ID":"20251028213701-k3zxvef","Type":"NodeParagraph","Properties":{"id":"20251028213701-k3zxvef","updated":"20251028213701"},"Children":[{"Type":"NodeText","Data":"特意的将数据分配在堆上"}]}]},{"ID":"20251028213701-xze7tb0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213701-xze7tb0","updated":"20251028213701"},"Children":[{"ID":"20251028213701-tir1c26","Type":"NodeParagraph","Properties":{"id":"20251028213701-tir1c26","updated":"20251028213701"},"Children":[{"Type":"NodeText","Data":"数据较大时，又不想在转移所有权时进行数据拷贝"}]}]},{"ID":"20251028213701-lv37825","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213701-lv37825","updated":"20251028213701"},"Children":[{"ID":"20251028213701-66wbh22","Type":"NodeParagraph","Properties":{"id":"20251028213701-66wbh22","updated":"20251028213701"},"Children":[{"Type":"NodeText","Data":"类型的大小在编译期无法确定，但是我们又需要固定大小的类型时"}]}]},{"ID":"20251028213701-5wcj40a","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028213701-5wcj40a","updated":"20251028213701"},"Children":[{"ID":"20251028213701-5hb0jwv","Type":"NodeParagraph","Properties":{"id":"20251028213701-5hb0jwv","updated":"20251028213701"},"Children":[{"Type":"NodeText","Data":"特征对象，用于说明对象实现了一个特征，而不是某个特定的类型"}]}]}]},{"ID":"20251028215326-08p29kn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028215326-08p29kn","updated":"20251028215503"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A","TextMarkTextContent":"使用 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A","TextMarkTextContent":"Box\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E4%BD%BF%E7%94%A8-boxt-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A","TextMarkTextContent":" 将数据存储在堆上"}]},{"ID":"20251028215327-rkylej5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028215327-rkylej5","updated":"20251028215337"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let a = Box::new(3);\n    println!(\"a = {}\", a); // a = 3\n\n    // 下面一行代码将报错\n    // let b = a + 1; // cannot add `{integer}` to `Box\u003c{integer}\u003e`\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028215403-8oahs7l","Type":"NodeList","ListData":{},"Properties":{"id":"20251028215403-8oahs7l","updated":"20251028215403"},"Children":[{"ID":"20251028215403-b70x3h6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028215403-b70x3h6","updated":"20251028215403"},"Children":[{"ID":"20251028215403-e8r78gr","Type":"NodeParagraph","Properties":{"id":"20251028215403-e8r78gr","updated":"20251028215403"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"println!"},{"Type":"NodeText","Data":"​ 可以正常打印出 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 的值，是因为它隐式地调用了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 对智能指针 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 进行了解引用"}]}]},{"ID":"20251028215403-e18h5jo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028215403-e18h5jo","updated":"20251028215403"},"Children":[{"ID":"20251028215403-iq1nbt7","Type":"NodeParagraph","Properties":{"id":"20251028215403-iq1nbt7","updated":"20251028215403"},"Children":[{"Type":"NodeText","Data":"最后一行代码 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"let b = a + 1"},{"Type":"NodeText","Data":"​ 报错，是因为在表达式中，我们无法自动隐式地执行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 解引用操作，你需要使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"*"},{"Type":"NodeText","Data":"​ 操作符 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"let b = *a + 1"},{"Type":"NodeText","Data":"​，来显式的进行解引用"}]}]},{"ID":"20251028215403-29seq4e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251028215403-29seq4e","updated":"20251028215403"},"Children":[{"ID":"20251028215403-khnbhhq","Type":"NodeParagraph","Properties":{"id":"20251028215403-khnbhhq","updated":"20251028215403"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 持有的智能指针将在作用域结束（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"main"},{"Type":"NodeText","Data":"​ 函数结束）时，被释放掉，这是因为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Drop"},{"Type":"NodeText","Data":"​ 特征"}]}]}]},{"ID":"20251028215503-54f3ico","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028215503-54f3ico","updated":"20251028215504"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E9%81%BF%E5%85%8D%E6%A0%88%E4%B8%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%B7%E8%B4%9D","TextMarkTextContent":"避免栈上数据的拷贝"}]},{"ID":"20251028215511-7ktkq30","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028215511-7ktkq30","updated":"20251028220411"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B","TextMarkTextContent":"将动态大小类型变为 Sized 固定大小类型"}]},{"ID":"20251028215512-w57lwej","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028215512-w57lwej","linewrap":"true","updated":"20251028220410"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"其中一种无法在编译时知道大小的类型是递归类型：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间\nenum List {\n    Cons(i32, List),  //错误！！，\n    Nil,\n}\n\nenum List {\n    Cons(i32, Box\u003cList\u003e),  //留下了一个栈指针，指向堆的数据\n    Nil,\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028220641-3pfzfc2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251028220641-3pfzfc2","updated":"20251028220647"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1","TextMarkTextContent":"特征对象"},{"Type":"NodeText","Data":"：不想说了，拜拜"}]},{"ID":"20251028220652-j7mq7ix","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028220652-j7mq7ix","updated":"20251028221120"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#box-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80","TextMarkTextContent":"Box 内存布局"}]},{"ID":"20251028220709-r90e1vf","Type":"NodeParagraph","Properties":{"id":"20251028220709-r90e1vf","updated":"20251028220709"},"Children":[{"Type":"NodeText","Data":"先来看看 Vec\u003ci32\u003e 的内存布局："}]},{"ID":"20251028220709-q3vu5lz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028220709-q3vu5lz","updated":"20251028220733"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"(stack)    (heap)\n┌──────┐   ┌───┐\n│ vec1 │──→│ 1 │\n└──────┘   ├───┤\n           │ 2 │\n           ├───┤\n           │ 3 │\n           ├───┤\n           │ 4 │\n           └───┘\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028220732-pd9kkgm","Type":"NodeParagraph","Properties":{"id":"20251028220732-pd9kkgm","updated":"20251028220751"},"Children":[{"Type":"NodeText","Data":"那如果数组中每个元素都是一个 Box 对象呢？来看看 Vec\u003cBox\u003ci32\u003e\u003e 的内存布局："}]},{"ID":"20251028220751-jrgd20l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028220751-jrgd20l","updated":"20251028220756"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"                    (heap)\n(stack)    (heap)   ┌───┐\n┌──────┐   ┌───┐ ┌─→│ 1 │\n│ vec2 │──→│B1 │─┘  └───┘\n└──────┘   ├───┤    ┌───┐\n           │B2 │───→│ 2 │\n           ├───┤    └───┘\n           │B3 │─┐  ┌───┐\n           ├───┤ └─→│ 3 │\n           │B4 │─┐  └───┘\n           └───┘ │  ┌───┐\n                 └─→│ 4 │\n                    └───┘\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028220757-af3zgdg","Type":"NodeParagraph","Properties":{"id":"20251028220757-af3zgdg","updated":"20251028221108"},"Children":[{"Type":"NodeText","Data":"例子"}]},{"ID":"20251028221109-3d6oye1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028221109-3d6oye1","updated":"20251028221119"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let arr = vec![Box::new(1), Box::new(2)];\n    let (first, second) = (\u0026arr[0], \u0026arr[1]);\n    let sum = **first + **second;\n\n    let arr = vec![1, 2];\n    let (first, second) = (\u0026arr[0], \u0026arr[1]);\n    let sum = *first as u32 + *second as u32;  //*号解引用\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028221149-wfvgvsx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251028221149-wfvgvsx","updated":"20251028222731"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/box.html#boxleak","TextMarkTextContent":"Box::leak"}]},{"ID":"20251028221157-vyc14yh","Type":"NodeParagraph","Properties":{"id":"20251028221157-vyc14yh","updated":"20251028221157"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box"},{"Type":"NodeText","Data":"​ 中还提供了一个非常有用的关联函数："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box::leak"},{"Type":"NodeText","Data":"​，它可以消费掉 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Box"},{"Type":"NodeText","Data":"​ 并且强制目标值从内存中泄漏，读者可能会觉得，这有啥用啊？"}]},{"ID":"20251028221150-w6iogsh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028221150-w6iogsh","updated":"20251028222625"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n   let s = gen_static_str();\n   println!(\"{}\", s);\n}\n\nfn gen_static_str() -\u003e \u0026'static str{\n    let mut s = String::new();\n    s.push_str(\"hello, world\");\n\n    Box::leak(s.into_boxed_str())  //返回了一个 Box\u003cstr\u003e\n\t// Box::leak(Box::new(s))  并不建议这总写法，因为不会释放虚表大小等参数，浪费内存  返回的是Box\u003cString\u003e\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251028221224-i2ler6g","Type":"NodeParagraph","Properties":{"id":"20251028221224-i2ler6g","updated":"20251028221941"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久"}]},{"ID":"20251028221942-wrffjie","Type":"NodeParagraph","Properties":{"id":"20251028221942-wrffjie","updated":"20251028222727"},"Children":[{"Type":"NodeText","Data":"into_boxed_str方法："}]},{"ID":"20251028222727-g07im5d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251028222727-g07im5d","updated":"20251028222731"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"// 转换前：String\n┌─────────────────┐ 栈\n│ ptr │ len │ cap │\n│  ↓  │  5  │  8  │ ← capacity 可能比 len 大\n└──┼──────────────┘\n   ↓\n┌──────────────────┐ 堆\n│ h e l l o _ _ _  │ ← 分配了8字节\n└──────────────────┘\n\n// 转换后：Box\u003cstr\u003e\n┌─────────────────┐ 栈\n│ ptr │ len │     │ ← Box\u003cstr\u003e 是胖指针\n│  ↓  │  5  │     │    (16字节)\n└──┼──────────────┘\n   ↓\n┌──────────────────┐ 堆\n│ h e l l o        │ ← 只有5字节（释放了多余空间）\n└──────────────────┘\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}