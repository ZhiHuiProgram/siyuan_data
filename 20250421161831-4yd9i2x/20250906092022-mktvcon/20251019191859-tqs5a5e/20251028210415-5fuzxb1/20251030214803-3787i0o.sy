{"ID":"20251030214803-3787i0o","Spec":"1","Type":"NodeDocument","Properties":{"id":"20251030214803-3787i0o","title":"Rc 与 Arc","type":"doc","updated":"20251030221756"},"Children":[{"ID":"20251030214803-q64zxlv","Type":"NodeParagraph","Properties":{"id":"20251030214803-q64zxlv","updated":"20251030214916"},"Children":[{"Type":"NodeText","Data":"问题："}]},{"ID":"20251030214917-rlg7cxr","Type":"NodeList","ListData":{},"Properties":{"id":"20251030214917-rlg7cxr","updated":"20251030214917"},"Children":[{"ID":"20251030214917-pq7z4fe","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030214917-pq7z4fe","updated":"20251030214917"},"Children":[{"ID":"20251030214917-6yag8hy","Type":"NodeParagraph","Properties":{"id":"20251030214917-6yag8hy","updated":"20251030214917"},"Children":[{"Type":"NodeText","Data":"在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理"}]}]},{"ID":"20251030214917-yy2mu50","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030214917-yy2mu50","updated":"20251030214917"},"Children":[{"ID":"20251030214917-r4d6m9t","Type":"NodeParagraph","Properties":{"id":"20251030214917-r4d6m9t","updated":"20251030214917"},"Children":[{"Type":"NodeText","Data":"在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用"}]}]}]},{"ID":"20251030214916-e5gh2r6","Type":"NodeParagraph","Properties":{"id":"20251030214916-e5gh2r6","updated":"20251030214917"},"Children":[{"Type":"NodeText","Data":"通过引用计数的方式，允许一个数据资源在同一时刻拥有多个所有者。"}]},{"ID":"20251030214906-8o9f2wg","Type":"NodeParagraph","Properties":{"id":"20251030214906-8o9f2wg","updated":"20251030214942"},"Children":[{"Type":"NodeText","Data":"这种实现机制就是 Rc 和 Arc，前者适用于单线程，后者适用于多线程"}]},{"ID":"20251030214947-3ofkl5w","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251030214947-3ofkl5w","updated":"20251030221303"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#rct","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251030214957-ss7i51m","Type":"NodeParagraph","Properties":{"id":"20251030214957-ss7i51m","updated":"20251030214958"},"Children":[{"Type":"NodeText","Data":"引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。"}]},{"ID":"20251030214958-5pg5ild","Type":"NodeParagraph","Properties":{"id":"20251030214958-5pg5ild","updated":"20251030215504"},"Children":[{"Type":"NodeText","Data":"当我们"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"Rc"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"成为数据值的所有者"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251030215505-9ndilrj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251030215505-9ndilrj","updated":"20251030215728"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    let s = String::from(\"hello, world\");\n    // s在这里被转移给a\n    let a = Box::new(s);\n    // 报错！此处继续尝试将 s 转移给 b\n    let b = Box::new(s);\n}\n\nuse std::rc::Rc;\nfn main() {\n    let a = Rc::new(String::from(\"hello, world\"));  //智能指针 Rc\u003cT\u003e 在创建时，还会将引用计数加 1\n    let b = Rc::clone(\u0026a);    //clone 只是浅拷贝，这里的 clone 仅仅复制了智能指针并增加了引用计数，并没有克隆底层数据\n    // drop(b);\n    assert_eq!(2, Rc::strong_count(\u0026a));\n    assert_eq!(Rc::strong_count(\u0026a), Rc::strong_count(\u0026b))\n}\n也可以使用 a.clone() 的方式来克隆，但是从可读性角度，我们更加推荐 Rc::clone 的方式。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251030215518-2rspwly","Type":"NodeParagraph","Properties":{"id":"20251030215518-2rspwly","updated":"20251030220822"},"Children":[{"Type":"NodeText","Data":"多重引用的例子 ：可以运行"}]},{"ID":"20251030220733-cs323tp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251030220733-cs323tp","updated":"20251030220817"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"fn main() {\n    // 创建一个基于引用计数的 `Owner`.\n    let gadget_owner: Rc\u003cOwner\u003e = Rc::new(Owner {\n        name: \"Gadget Man\".to_string(),\n    });\n    // 创建两个不同的工具，它们属于同一个主人\n    let gadget1 = Gadget {\n        id: 1,\n        owner: Rc::clone(\u0026gadget_owner),\n    };\n    let gadget2 = Gadget {\n        id: 2,\n        owner: Rc::clone(\u0026gadget_owner),\n    };\n\tdrop(gadget_owner);\n\tprintln!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);  \n    println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251030220834-oife5o4","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251030220834-oife5o4","updated":"20251030221303"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#rc-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93","TextMarkTextContent":"Rc 简单总结"}]},{"ID":"20251030220905-ezhax1g","Type":"NodeList","ListData":{},"Properties":{"id":"20251030220905-ezhax1g","updated":"20251030220905"},"Children":[{"ID":"20251030220905-juqcmps","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030220905-juqcmps","updated":"20251030220905"},"Children":[{"ID":"20251030220905-jpvwg6x","Type":"NodeParagraph","Properties":{"id":"20251030220905-jpvwg6x","updated":"20251030220905"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc/Arc"},{"Type":"NodeText","Data":"​ 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RefCell"},{"Type":"NodeText","Data":"​ 或互斥锁 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251030220905-yu9c7u4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030220905-yu9c7u4","updated":"20251030220905"},"Children":[{"ID":"20251030220905-xjbxna5","Type":"NodeParagraph","Properties":{"id":"20251030220905-xjbxna5","updated":"20251030220905"},"Children":[{"Type":"NodeText","Data":"一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的"}]}]},{"ID":"20251030220905-sfmnpx1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030220905-sfmnpx1","updated":"20251030220905"},"Children":[{"ID":"20251030220905-6mh9ici","Type":"NodeParagraph","Properties":{"id":"20251030220905-6mh9ici","updated":"20251030220905"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc"},{"Type":"NodeText","Data":"​ 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20251030220905-inbn45i","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20251030220905-inbn45i","updated":"20251030220905"},"Children":[{"ID":"20251030220905-kol4uqz","Type":"NodeParagraph","Properties":{"id":"20251030220905-kol4uqz","updated":"20251030220905"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 是一个智能指针，实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Deref"},{"Type":"NodeText","Data":"​ 特征，因此你无需先解开 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc"},{"Type":"NodeText","Data":"​ 指针，再使用里面的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​，而是可以直接使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​，例如上例中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"gadget1.owner.name"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20251030220917-a6orcef","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251030220917-a6orcef","updated":"20251030221335"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%8A%9B%E7%9A%84-rct","TextMarkTextContent":"多线程无力的 "},{"Type":"NodeTextMark","TextMarkType":"a code","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%8A%9B%E7%9A%84-rct","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20251030221306-d98gg8h","Type":"NodeParagraph","Properties":{"id":"20251030221306-d98gg8h","updated":"20251030221323"},"Children":[{"Type":"NodeText","Data":"表面原因是 Rc\u003cT\u003e 不能在线程间安全的传递，实际上是因为它没有实现 Send 特征，而该特征是恰恰是多线程间传递数据的关键"}]},{"ID":"20251030221338-rlmznqh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20251030221338-rlmznqh","updated":"20251030221756"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#arc","TextMarkTextContent":"Arc"}]},{"ID":"20251030221339-oq563bc","Type":"NodeParagraph","Properties":{"id":"20251030221339-oq563bc","updated":"20251030221426"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Arc"},{"Type":"NodeText","Data":"​ 是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Atomic Rc"},{"Type":"NodeText","Data":"​ 的缩写，顾名思义：原子化的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Rc\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 智能指针。原子化是一种并发原语，我们在后续章节会进行深入讲解，这里你只要知道它能保证我们的数据能够安全的在线程间共享即可。"}]},{"ID":"20251030221500-2sluaxa","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20251030221500-2sluaxa","updated":"20251030221756"},"Children":[{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://course.rs/advance/smart-pointer/rc-arc.html#arc-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97","TextMarkTextContent":"Arc 的性能损耗"}]},{"ID":"20251030221501-1eq6z6k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251030221501-1eq6z6k","updated":"20251030221623"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"原因在于原子化或者其它锁虽然可以带来的线程安全，但是都会伴随着性能损耗，而且这种性能损耗还不小\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251030221335-zmp0gqc","Type":"NodeParagraph","Properties":{"id":"20251030221335-zmp0gqc","updated":"20251030221637"},"Children":[{"Type":"NodeText","Data":"使用方法："}]},{"ID":"20251030221637-c61sfdc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20251030221637-c61sfdc","updated":"20251030221638"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"aWZjb25maWc="},{"Type":"NodeCodeBlockCode","Data":"use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let s = Arc::new(String::from(\"多线程漫游者\"));\n    for _ in 0..10 {\n        let s = Arc::clone(\u0026s);\n        let handle = thread::spawn(move || {\n           println!(\"{}\", s)\n        });\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20251030221639-zxha4oc","Type":"NodeParagraph","Properties":{"id":"20251030221639-zxha4oc","style":"font-size: 26px;","updated":"20251030221756"},"Children":[{"Type":"NodeText","Data":"这两者都是只读的，如果想要实现内部数据可修改，必须配合内部可变性 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RefCell"},{"Type":"NodeText","Data":"​ 或者互斥锁 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Mutex"},{"Type":"NodeText","Data":"​ 来一起使用。"}]}]}